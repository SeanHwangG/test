> leetcode

* [Level 1 : Traffic Light Controlled Intersection](https://leetcode.com/problems/traffic-light-controlled-intersection)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/computer-science/concurrency/lock/LC_1279.md/)

{% tabs %}
{% tab title='LC_1279.md' %}

> Question

* Given intersection of two roads
* First road is road A where cars travel from North to South in direction 1 and from South to North in direction 2
* Second road is road B where cars travel from West to East in direction 3 and from East to West in direction 4

```txt
Input: cars = [1,3,5,2,4], directions = [2,1,2,4,3], arrivalTimes = [10,20,30,40,50]
Output: [
"Car 1 Has Passed Road A In Direction 2",    // Traffic light on road A is green, car 1 can cross the intersection.
"Car 3 Has Passed Road A In Direction 1",    // Car 3 crosses the intersection as the light is still green.
"Car 5 Has Passed Road A In Direction 2",    // Car 5 crosses the intersection as the light is still green.
"Traffic Light On Road B Is Green",          // Car 2 requests green light for road B.
"Car 2 Has Passed Road B In Direction 4",    // Car 2 crosses as the light is green on road B now.
"Car 4 Has Passed Road B In Direction 3"     // Car 4 crosses the intersection as the light is still green.
]
```

{% endtab %}
{% tab title='LC_1279.py' %}

```py
# Time:  O(n) Space: O(1)

import threading

class TrafficLight(object):
  def __init__(self):
    self.__l = threading.Lock()
    self.__light = 1

  def carArrived(self, carId, roadId, direction, turnGreen, crossCar):
    """
    :type roadId: int --> // ID of the car
    :type carId: int --> // ID of the road the car travels on. Can be 1 (road A) or 2 (road B)
    :type direction: int --> // Direction of the car
    :type turnGreen: method --> // Use turnGreen() to turn light to green on current road
    :type crossCar: method --> // Use crossCar() to make car cross the intersection
    """
    with self.__l:
      if self.__light != roadId:
        self.__light = roadId
        turnGreen()
      crossCar()
```

{% endtab %}
{% endtabs %}

* [Level 2 : The Dining Philosophers](https://leetcode.com/problems/the-dining-philosophers)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/computer-science/concurrency/lock/LC_1226.md/)

{% tabs %}
{% tab title='LC_1226.md' %}

> Question

* Five silent philosophers sit at a round table with bowls of spaghetti. Forks are placed between each pair of adjacent philosophers
* Design a behaviour st no philosopher will starve
* each can forever continue to alternate between eating and thinking
* assuming that no philosopher can know when others may want to eat or think

```txt
Input: n = 1
Output: [[4,2,1],[4,1,1],[0,1,1],[2,2,1],[2,1,1],[2,0,3],[2,1,2],[2,2,2],[4,0,3],[4,1,2],[0,2,1],[4,2,2],[3,2,1],[3,1,1],[0,0,3],[0,1,2],[0,2,2],[1,2,1],[1,1,1],[3,0,3],[3,1,2],[3,2,2],[1,0,3],[1,1,2],[1,2,2]]
```

{% endtab %}
{% tab title='LC_1226.py' %}

```py
from threading import Lock
class DiningPhilosophers:

  def __init__(self):
    self.locks = [Lock() for _ in range(5)]

  def wantsToEat(self, philosopher: int,
           pickLeftFork: 'Callable[[], None]',
           pickRightFork: 'Callable[[], None]',
           eat: 'Callable[[], None]',
           putLeftFork: 'Callable[[], None]',
           putRightFork: 'Callable[[], None]') -> None:
    if philosopher != 0:
      first, second = philosopher, (philosopher + 1) % 5
    else:
      second, first = philosopher, (philosopher + 1) % 5
    with (self.locks[first], self.locks[second]):
      pickLeftFork()
      pickRightFork()
      eat()
      putLeftFork()
      putRightFork()
```

{% endtab %}
{% endtabs %}
