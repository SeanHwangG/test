> leetcode

* [Level 2 : Print FooBar Alternately](https://leetcode.com/problems/print-foobar-alternately)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/computer-science/concurrency/semaphore/LC_1115.md/)

{% tabs %}
{% tab title='LC_1115.md' %}

> Question

* Print Foo bar alternatively

```txt
Input: n = 2
Output: "foobarfoobar"
```

> Solution

* Cpp: Semaphore
* Python: Barrior
* Java: Monitor

{% endtab %}
{% tab title='LC_1115.cpp' %}

```cpp
#include <semaphore.h>
class FooBar {
private:
  int n;
  sem_t s1,s2;

public:
  FooBar(int n) {
    this->n = n;
    sem_init(&s1, 0, 0);
    sem_init(&s2, 0, 1);
  }

  void foo(function<void()> printFoo) {
    for (int i = 0; i < n; i++) {
      sem_wait(&s2);
      printFoo();
      sem_post(&s1);
    }
  }

  void bar(function<void()> printBar) {
    for (int i = 0; i < n; i++) {
      sem_wait(&s1);
      printBar();
      sem_post(&s2);
    }
  }
};
```

{% endtab %}
{% tab title='LC_1115.java' %}

```java
public class FooBarSynchronized {
  private int n;
  private int flag = 0; // flag 0->foo to be print  1->foo has been printed

  public FooBarSynchronized(int n) { this.n = n; }
  public void foo(Runnable printFoo) throws InterruptedException {
    for (int i = 0; i < n; i++) {
      synchronized (this) {
        while (flag == 1) this.wait();
        printFoo.run();
        flag = 1;
        this.notifyAll();
      }
    }
  }

  public void bar(Runnable printBar) throws InterruptedException {
    for (int i = 0; i < n; i++) {
      synchronized (this) {
        while (flag == 0) this.wait();
        printBar.run();
        flag = 0;
        this.notifyAll();
      }
    }
  }
}
```

{% endtab %}
{% tab title='LC_1115.py' %}

```py
from threading import Barrier

class FooBar:
  def __init__(self, n):
    self.n = n
    self.barrier = Barrier(2)

  def foo(self, printFoo):
    for i in range(self.n):
      printFoo()
      self.barrier.wait()

  def bar(self, printBar):
    for i in range(self.n):
      self.barrier.wait()
      printBar()
```

{% endtab %}
{% endtabs %}

* [Level 2 : Print Zero Even Odd](https://leetcode.com/problems/print-zero-even-odd)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/computer-science/concurrency/semaphore/LC_1116.md/)

{% tabs %}
{% tab title='LC_1116.md' %}

> Question

* Thread A will call zero() which should only output 0's
* Thread B will call even() which should only ouput even numbers
* Thread C will call odd() which should only output odd numbers

```txt
Input: n = 5
Output: "0102030405"
```

> Solution

* cpp: lock
* Java: Semaphore
* Python: Condition

{% endtab %}
{% tab title='LC_1116.cpp' %}

```cpp
class ZeroEvenOdd {
private:
  int n;
  mutex em, om, zm;

public:
  ZeroEvenOdd(int n) {
    em.lock();
    om.lock();
    this->n = n;
  }

  // printNumber(x) outputs "x", where x is an integer.
  void zero(function<void(int)> printNumber) {
    for (int i = 0; i < n; i++) {
      zm.lock();
      printNumber(0);
      if (i % 2 == 0) om.unlock();
      else            em.unlock();
    }
  }

  void even(function<void(int)> printNumber) {
    for (int i = 2; i <= n; i+=2){
      em.lock();
      printNumber(i);
      zm.unlock();
    }
  }

  void odd(function<void(int)> printNumber) {
    for (int i = 1; i <= n; i+=2){
      om.lock();
      printNumber(i);
      zm.unlock();
    }
  }
};
```

{% endtab %}
{% tab title='LC_1116.java' %}

```java
import java.util.concurrent.*;
class ZeroEvenOdd {
  private int n;
  private Semaphore zeroSem, oddSem, evenSem;

  public ZeroEvenOdd(int n) {
    this.n = n;
    zeroSem = new Semaphore(1);
    oddSem = new Semaphore(0);
    evenSem = new Semaphore(0);
  }

  // printNumber.accept(x) outputs "x", where x is an integer.
  public void zero(IntConsumer printNumber) throws InterruptedException {
    for (int i = 0; i < n; ++i) {
      zeroSem.acquire();
      printNumber.accept(0);
      (i % 2 == 0 ? oddSem : evenSem).release(); // Alternately release odd() and even().
    }
  }

  public void even(IntConsumer printNumber) throws InterruptedException {
    for (int i = 2; i <= n; i += 2) {
      evenSem.acquire();
      printNumber.accept(i);
      zeroSem.release();
    }
  }

  public void odd(IntConsumer printNumber) throws InterruptedException {
    for (int i = 1; i <= n; i += 2) {
      oddSem.acquire();
      printNumber.accept(i);
      zeroSem.release();
    }
  }
}
```

{% endtab %}
{% tab title='LC_1116.py' %}

```py
from threading import Condition

class ZeroEvenOdd:
  def __init__(self, n):
    self.n = n
    self.sem = 0
    self.c = Condition()

  def zero(self, printNumber: 'Callable[[int], None]') -> None:
    for i in range(self.n):
      with self.c:
        while self.sem:
          self.c.wait()
        printNumber(0)
        self.sem = 2 if i % 2 else 1
        self.c.notify_all()

  def even(self, printNumber: 'Callable[[int], None]') -> None:
    for i in range(2, self.n + 1, 2):
      with self.c:
        while self.sem - 2:
          self.c.wait()
        printNumber(i)
        self.sem = 0
        self.c.notify_all()

  def odd(self, printNumber: 'Callable[[int], None]') -> None:
    for i in range(1, self.n + 1, 2):
      with self.c:
        while self.sem - 1:
          self.c.wait()
        printNumber(i)
        self.sem = 0
        self.c.notify_all()
```

{% endtab %}
{% endtabs %}

* [Level 2 : Building H2O](https://leetcode.com/problems/building-h2o)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/computer-science/concurrency/semaphore/LC_1117.md/)

{% tabs %}
{% tab title='LC_1117.md' %}

> Question

* You have function that prints h, o. Print hho sequentially

```txt
Input: "OOHHHH"
Output: "HHOHHO"  # "HOHHHO", "OHHHHO", "HHOHOH", "HOHHOH", "OHHHOH", "HHOOHH", "HOHOHH" and "OHHOHH" are also valid answers.
```

{% endtab %}
{% tab title='LC_1117.cpp' %}

```cpp
class H2O {
  mutex mtxHH, mtxO;
  atomic_int cntH, cntO;
  condition_variable cvO, cvH;
public:
  H2O() {
    cntH = 0;
    cntO = 0;
  }

  void hydrogen(function<void()> releaseHydrogen) {
    while (cntH == 2) {
      unique_lock<mutex> lck(mtxHH);
      cvH.wait(lck);
    }

    releaseHydrogen();
    cntH++;
    if (cntH == 2 && cntO == 1) {
      cntH = cntO = 0;
      cvO.notify_all();
    }
  }

  void oxygen(function<void()> releaseOxygen) {
    while (cntO == 1) {
      unique_lock<mutex> lck(mtxO);
      cvO.wait(lck);;
    }
    releaseOxygen();
    cntO++;
    if (cntH == 2) {
      cntH = cntO = 0;
      cvH.notify_all();
    }
  }
};
```

{% endtab %}
{% tab title='LC_1117.py' %}

```py
from threading import Barrier, Semaphore
class H2O:
  def __init__(self):
  self.b = Barrier(3)
  self.h = Semaphore(2)
  self.o = Semaphore(1)
  def hydrogen(self, releaseHydrogen: 'Callable[[], None]') -> None:
  self.h.acquire()
  self.b.wait()
  releaseHydrogen()
  self.h.release()
  def oxygen(self, releaseOxygen: 'Callable[[], None]') -> None:
  self.o.acquire()
  self.b.wait()
  releaseOxygen()
  self.o.release()
```

{% endtab %}
{% endtabs %}

* [Level 2 : Fizz Buzz Multithreaded](https://leetcode.com/problems/fizz-buzz-multithreaded)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/computer-science/concurrency/semaphore/LC_1195.md/)

{% tabs %}
{% tab title='LC_1195.md' %}

> Question

* Print fizz buzz given 4 threads
  * a thread printing fizz
  * a thread printing buzz
  * a thread printing fizzbuzz
  * a thread incrementing a number

{% endtab %}
{% tab title='LC_1195.cpp' %}

```cpp
class FizzBuzz {
  private:
    int n;
    atomic<int> current;
    mutex mx;
    condition_variable cv;
  public:
    FizzBuzz(int n) {
      this->n = n;
      current = 1;
    }

    void fizz(function<void()> printFizz) {
      do_work([&](int i){printFizz();}, [&]{ return (current % 3 == 0 && current % 5 != 0);});
    }

    void buzz(function<void()> printBuzz) {
      do_work([&](int i){printBuzz();}, [&]{ return (current % 5 == 0 && current % 3 != 0);});
    }

    void fizzbuzz(function<void()> printFizzBuzz) {
      do_work([&](int i){printFizzBuzz();}, [&]{ return (current % 5 == 0 && current % 3 == 0);});
    }

    void number(function<void(int)> printNumber)  {
      do_work(printNumber, [&]{ return (current % 5 != 0 && current % 3 != 0);});
    }
  protected:
    void do_work(function<void(int)> printFunc, function<bool()> evalFunc) {
      while(current <= n) {
        unique_lock<mutex> ul(mx);
        cv.wait(ul, [&]{ return (evalFunc() || current > n);});
        if(current > n) break;
        printFunc(current);
        ++current;
        cv.notify_all();
      }
    }
};
```

{% endtab %}
{% tab title='LC_1195.py' %}

```py
from threading import Semaphore
class FizzBuzz(object):
  def __init__(self, n):
    self.n = n
    self.sem0 = Semaphore(1)
    self.sem3 = Semaphore(0)
    self.sem5 = Semaphore(0)
    self.sem15 = Semaphore(0)
  def fizz(self, printFizz):
    for i in range(3, self.n + 1, 3):
      if i % 15:
        self.sem3.acquire()
        printFizz()
        self._release(i+1)

  def buzz(self, printBuzz):
    for i in range(5, self.n + 1, 5):
      if i % 15:
        self.sem5.acquire()
        printBuzz()
        self._release(i+1)

  def fizzbuzz(self, printFizzBuzz):
    for i in range(15, self.n + 1, 15):
      self.sem15.acquire()
      printFizzBuzz()
      self._release(i+1)

  def number(self, printNumber):
    for i in range(1, self.n + 1):
      if i % 3 and i % 5:
        self.sem0.acquire()
        printNumber(i)
        self._release(i+1)

  def _release(self, i):
    if i % 3 and i % 5:
      self.sem0.release()
    elif i % 5:
      self.sem3.release()
    elif i % 3:
      self.sem5.release()
    else:
      self.sem15.release()
```

{% endtab %}
{% endtabs %}
