> leetcode

* [Level 2 : LRU Cache](https://leetcode.com/problems/lru-cache)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/computer-science/os/cache/LC_146.md/)

{% tabs %}
{% tab title='LC_146.md' %}

> Question

* Implement the LRUCache class
* LRUCache(int capacity) Initialize the LRU cache with positive size capacity
  * int get(int key) Return the value of the key if the key exists, otherwise return -1
  * void put(int key, int value) Update value of key if key exists. Otherwise, add key-value pair to cache
    * If number of keys exceeds capacity from this operation, evict least recently used key

```txt
Input:
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]

Output: [null, null, null, 1, null, -1, null, -1, 3, 4]
```

{% endtab %}
{% tab title='LC_146.py' %}

```py
class LRUCache:
  def __init__(self, Capacity):
    self.size = Capacity
    self.cache = OrderedDict()

  def get(self, key):
    if key not in self.cache: return -1
    val = self.cache[key]
    self.cache.move_to_end(key)
    return val

  def put(self, key, val):
    self.cache.pop(key, None)
    self.cache[key] = val
    if len(self.cache) > self.size:
      self.cache.popitem(last=False)
```

{% endtab %}
{% endtabs %}

* [Level 3 : LFU Cache](https://leetcode.com/problems/lfu-cache)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/computer-science/os/cache/LC_460.md/)

{% tabs %}
{% tab title='LC_460.md' %}

> Question

* Deisng LFU Cache

```txt
Input:
["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]

Output:
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]
```

{% endtab %}
{% tab title='LC_460.py' %}

```py
from collections import defaultdict, OrderedDict

class Node:
  def __init__(self, key, val, count):
    self.key = key
    self.val = val
    self.count = count

class LFUCache(object):
  def __init__(self, capacity):
    self.cap = capacity
    self.key2node = {}
    self.count2node = defaultdict(OrderedDict)
    self.minCount = None

  def get(self, key):
    if key not in self.key2node:
      return -1

    node = self.key2node[key]
    del self.count2node[node.count][key]

    if not self.count2node[node.count]:
      del self.count2node[node.count]

    node.count += 1
    self.count2node[node.count][key] = node

    if not self.count2node[self.minCount]:
      self.minCount += 1

    return node.val

  def put(self, key, value):
    if not self.cap:
      return

    if key in self.key2node:
      self.key2node[key].val = value
      self.get(key) # NOTICE, put makes count+1 too
      return

    if len(self.key2node) == self.cap:
      # popitem(last=False) is FIFO, like queue
      k, n = self.count2node[self.minCount].popitem(last=False)
      del self.key2node[k]

    self.count2node[1][key] = self.key2node[key] = Node(key, value, 1)
    self.minCount = 1
```

{% endtab %}
{% endtabs %}
