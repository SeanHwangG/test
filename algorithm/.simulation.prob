> baekjoon

* [Level 11 : Puyo Puyo](https://www.acmicpc.net/problem/11559)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/simulation/BJ_11559.md/)

{% tabs %}
{% tab title='BJ_11559.md' %}

> Question

* Keep pop puzzle if 4 or more pieces are connected

```txt
Input:
......
......
......
......
......
......
......
......
.Y....
.YG...
RRYG..
RRYGG.

Output: 3
```

{% endtab %}
{% tab title='BJ_11559.py' %}

```py
def pop(si, sj):
  if grid[si][sj] == '.':
    return 0
  vis, stk = {(si, sj)}, [(si, sj)]
  while stk:
    i, j = stk.pop()
    for ni, nj in (i-1,j), (i+1,j), (i,j-1), (i,j+1):
      if (ni,nj) in vis: continue
      if 0 <= ni < 12 and 0 <= nj < 6 and grid[ni][nj] == grid[si][sj]:
        stk.append((ni,nj))
        vis.add((ni,nj))
  if len(vis) >= 4:
    for i, j in vis:
      grid[i][j] = '.'
    return 1
  return 0

grid = [list(input()) for i in range(12)]
for cycle in range(72):
  if sum(pop(i, j) for i in range(12) for j in range(6)) == 0:
    print(cycle)
    break
  for j in range(6):
    pi = 11
    for i in range(11, -1, -1):
      if grid[i][j] != '.':
        grid[i][j], grid[pi][j] = '.', grid[i][j]
        pi-= 1
```

{% endtab %}
{% endtabs %}

* [Level 11 : 주사위 굴리기](https://www.acmicpc.net/problem/14499)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/simulation/BJ_14499.md/)

{% tabs %}
{% tab title='BJ_14499.md' %}

> Question

* Given NxM map, roll dice with 0 on six sides K times
* Value on map will be copied to dice
* Print digit that appears on top each time

```txt
Input:
4 2 0 0 8
0 2
3 4
5 6
7 8
4 4 4 1 3 3 3 2

Output:
0
0
3
0
0
8
6
3

Input:
3 3 1 1 9
1 2 3
4 0 5
6 7 8
1 3 2 2 4 4 1 1 3

Ouput:
0
0
0
3
0
1
0
6
0
```

{% endtab %}
{% tab title='BJ_14499.py' %}

```py
n, m, x, y, k = map(int, input().split())
a = [[*map(int, input().split())] for _ in range(n)]
d = [0, 0, 0, 0, 0, 0]
for t in map(int, input().split()):
  if t == 1 and y != m - 1:
    y += 1
    d[0], d[1], d[3], d[5] = d[3], d[0], d[5], d[1]
  elif t == 2 and y != 0:
    y -= 1
    d[0], d[1], d[3], d[5] = d[1], d[5], d[0], d[3]
  elif t == 3 and x != 0:
    x -= 1
    d[0], d[2], d[4], d[5] = d[2], d[5], d[0], d[4]
  elif t == 4 and x != n - 1:
    x += 1
    d[0], d[2], d[4], d[5] = d[4], d[0], d[5], d[2]
  else:
    continue
  if a[x][y]:
    d[5] = a[x][y]
    a[x][y] = 0
  else:
    a[x][y] = d[5]
  print(d[0])
```

{% endtab %}
{% endtabs %}

* [Level 11 : 로봇 청소기](https://www.acmicpc.net/problem/14503)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/simulation/BJ_14503.md/)

{% tabs %}
{% tab title='BJ_14503.md' %}

> Question

* Count number of cells cleaned by robot

```txt
Input:
3 3
1 1 0
1 1 1
1 0 1
1 1 1

Output:
1
```

{% endtab %}
{% tab title='BJ_14503.py' %}

```py
N, M, r, c, d = map(int, (input() + ' ' + input()).split())
G = [list(map(int,input().split())) for _ in range(N)]
x, y = [0,1,0,-1], [-1,0,1,0]
while 1:
  G[r][c] = 2
  t = 0
  for _ in range(4):
    d = (d - 1) % 4
    if G[r + y[d]][c + x[d]]==0:
      t = 1
      r += y[d]
      c += x[d]
      break
  if t:
    pass
  elif G[r+y[d - 2]][c + x[d - 2]] == 1:
    break
  else:
    r += y[d - 2]
    c += x[d - 2]
print(sum(l.count(2) for l in G))
```

{% endtab %}
{% endtabs %}

* [Level 11 : 뱀](https://www.acmicpc.net/problem/3190)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/simulation/BJ_3190.md/)

{% tabs %}
{% tab title='BJ_3190.md' %}

> Question

* Simulate Snake controller game and estimate end time

```txt
Input:
6
3
3 4
2 5
5 3
3
3 D
15 L
17 D

Output: 9
```

{% endtab %}
{% tab title='BJ_3190.cpp' %}

```cpp
#include <bits/stdc++.h>

using namespace std;
int N, K, L, c, r, t = -1, idx,  b[101][101];

const int dr[] = { 1, 0, -1, 0 };
const int dc[] = { 0, 1, 0, -1 };
char ch;
queue<pair<int, int>> snake, direct;
int main() {
  cin >> N >> K;
  for (int i = 0; i < K; i++) {
    cin >> c >> r;
    b[r][c] = 1;
  }
  cin >> L;
  while (L--){
    cin >> r >> ch;
    direct.push({ ch == 'L' ? 3 : 1 , r});
  }
  c = r = 1;
  while (true) {
    if (c < 1 || N < c || r < 1 || N < r || b[r][c] == 2) {
      cout << t + 1 << endl;
      return 0;
    }
    if (!b[r][c] && !snake.empty()) {
      b[snake.front().first][snake.front().second] = 0;
      snake.pop();
    }
    t++, b[r][c] = 2;
    if (!direct.empty() && t == direct.front().second) {
      idx = (idx + direct.front().first) % 4;
      direct.pop();
    }
    snake.push({ r, c });
    c += dc[idx], r += dr[idx];
  }
  return 0;
}
```

{% endtab %}
{% tab title='BJ_3190.py' %}

```py
N = int(input())
app = [list(map(int, input().split())) for _ in range(int(input()))]
L = int(input())
turn = {}

for _ in range(L):
  x, y = input().split()
  turn[int(x)] = y

x, y = 1, 1
t, dr = 0, 0
route = [[1,1]]

while True:
  t += 1
  if dr % 2 == 0:
    x += (-1) ** (dr // 2)
  else:
    y += (-1) ** ((dr - 1) // 2)
  if x > N or y > N or route.count([x, y]) or x <= 0 or y <= 0:
    print(t)
    break
  route.append([x, y])
  if app.count([y, x]) == 0:
    del route[0]
  else:
    app.remove([y, x])
  if turn.get(t) == 'L':
    dr += 3
  elif turn.get(t) == 'D':
    dr += 1
```

{% endtab %}
{% endtabs %}

* [Level 16 : 큐빙](https://www.acmicpc.net/problem/5373)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/simulation/BJ_5373.md/)

{% tabs %}
{% tab title='BJ_5373.md' %}

> Question

* Print shape of rubiks cube after rotating N times
* \+ is clockwise, - is counter clockwise

```txt
Input:
4
1
L-
2
F+ B+
4
U- D- L+ R+
10
L- U- L+ U- L- U- U- L+ U+ U+

Output:
rww
rww
rww
bbb
www
ggg
gwg
owr
bwb
gwo
www
rww
```

{% endtab %}
{% tab title='BJ_5373.py' %}

```py
def rotate(c):
  T, X, Y, Z, W = U, L, F, R, B
  if c == 'L':
    T, X, Y, Z, W = L, F, U, B, D
  if c == 'F':
    T, X, Y, Z, W = F, U, L, D, R
  if c == 'R':
    T, X, Y, Z, W = R, D, B, U, F
  if c == 'B':
    T, X, Y, Z, W = B, R, D, L, U
  if c == 'D':
    T, X, Y, Z, W = D, B, R, F, L

  T[0][2], T[1][2], T[2][2], T[2][1], T[2][0], T[1][0], T[0][0], T[0][1] = \
    T[0][0], T[0][1], T[0][2], T[1][2], T[2][2], T[2][1], T[2][0], T[1][0]

  X[2][2], X[2][1], X[2][0], Y[2][0], Y[1][0], Y[0][0], Z[0][2], Z[1][2], Z[2][2], W[0][0], W[0][1], W[0][2] = \
    Y[2][0], Y[1][0], Y[0][0], Z[0][2], Z[1][2], Z[2][2], W[0][0], W[0][1], W[0][2], X[2][2], X[2][1], X[2][0]

for _ in range(int(input())):
  U = [['w'] * 3 for _ in range(3)]
  D = [['y'] * 3 for _ in range(3)]
  F = [['r'] * 3 for _ in range(3)]
  B = [['o'] * 3 for _ in range(3)]
  L = [['g'] * 3 for _ in range(3)]
  R = [['b'] * 3 for _ in range(3)]
  n = int(input())
  data = list(input().split())
  for area, d in data:
    rotate(area)
    if d == '-':
      rotate(area)
      rotate(area)
  for i in range(3):
    print("".join(j for j in U[i]))
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 2 : Candy Crush](https://leetcode.com/problems/candy-crush)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/simulation/LC_723.md/)

{% tabs %}
{% tab title='LC_723.md' %}

> Question

* Simulate Candicrush

```txt
Input:
board =
[[110,5,112,113,114],
 [210,211,5,213,214],
 [310,311,3,313,314],
 [410,411,412,5,414],
 [5,1,512,3,3],
 [610,4,1,613,614],
 [710,1,2,713,714],
 [810,1,2,1,1],
 [1,1,2,2,2],
 [4,1,4,4,1014]]
Output:
[[0,0,0,0,0],
 [0,0,0,0,0],
 [0,0,0,0,0],
 [110,0,0,0,114],
 [210,0,0,0,214],
 [310,0,0,113,314],
 [410,0,0,213,414],
 [610,211,112,313,614],
 [710,311,412,613,714],
 [810,411,512,713,1014]]
```

{% endtab %}
{% tab title='LC_723.py' %}

```py
def candyCrush(self, board: List[List[int]]) -> List[List[int]]:
  row, col = len(board), len(board[0])
  todo = False

  for r in range(row - 2):
    for c in range(col):
      if abs(board[r][c]) == abs(board[r + 1][c]) == abs(board[r + 2][c]) != 0:
        board[r][c] = board[r + 1][c] = board[r + 2][c] = -abs(board[r][c])
        todo = True

  for r in range(row):
    for c in range(col - 2):
      if abs(board[r][c]) == abs(board[r][c + 1]) == abs(board[r][c + 2]) != 0:
        board[r][c] = board[r][c + 1] = board[r][c + 2] = -abs(board[r][c])
        todo = True

  for c in range(col):
    wp = row - 1
    for r in range(row - 1, -1, -1):
      if board[r][c] > 0:
        board[wp][c] = board[r][c]
        wp -= 1

    for wp in range(wp, -1, -1):
      board[wp][c] = 0

  return self.candyCrush(board) if todo else board
```

{% endtab %}
{% endtabs %}
