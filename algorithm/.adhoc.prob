> baekjoon

* [Level 7 : 병든 나이트](https://www.acmicpc.net/problem/1783)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/adhoc/BJ_1783.md/)

{% tabs %}
{% tab title='BJ_1783.md' %}

> Question

* If Night moves greater than 3, it has to take all possible moves
* Given chessboard, find the maximum number of grids that knight can go

```txt
Input: 20 4
Output: 4
```

{% endtab %}
{% tab title='BJ_1783.py' %}

```py
n, m = map(int, input().split())
if n == 1:
  print(1)
elif n == 2:
  print(min(4, (m + 1) // 2))
elif m <= 6:
  print(min(4, m))
else:
  print(m - 2)
```

{% endtab %}
{% endtabs %}

* [Level 11 : 회문은 회문아니야!!](https://www.acmicpc.net/problem/15927)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/adhoc/BJ_15927.md/)

{% tabs %}
{% tab title='BJ_15927.md' %}

> Question

* Find longest substring that are not a palindrome (-1 if there isn't)

```txt
Input: PALINDROME
Output: 10
```

{% endtab %}
{% tab title='BJ_15927.py' %}

```py
S = input()
if S == S[0]*len(S): print(-1)
elif S != S[::-1]: print(len(S))
else: print(len(S)-1)
```

{% endtab %}
{% endtabs %}

* [Level 14 : 집으로](https://www.acmicpc.net/problem/1069)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/adhoc/BJ_1069.md/)

{% tabs %}
{% tab title='BJ_1069.md' %}

> Question

* You can move 1 block per second or jump D which takes T seconds
* Starting at x, y, find minimum time to go to 0, 0

```txt
Input: 6 8 5 3
Output: 6.0
```

{% endtab %}
{% tab title='BJ_1069.py' %}

```py
x, y, d, t = map(int,input().split())
a = (x*x+y*y) ** 0.5
if d < t:
  print(a)
else:
  n = a // d
  if d < a:
    print(min(t * n + a - d * n, t * (n + 1)))
  else:
    print(min(a, t + d - a, 2 * t))
```

{% endtab %}
{% endtabs %}

* [Level 16 : 두 번 뒤집기](https://www.acmicpc.net/problem/2505)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/adhoc/BJ_2505.md/)

{% tabs %}
{% tab title='BJ_2505.md' %}

> Question

* Print two segment where you have to reverse to make array increasing
* Solution is guaranteed to exist

```txt
Input:
10
6 7 8 2 1 5 4 3 9 10

Output:
1 5
3 8
```

{% endtab %}
{% tab title='BJ_2505.py' %}

```py
from copy import deepcopy

def reverse(li, l, r, step):
  ret = []
  for i in range(l, r + step, step):
    if li[i - 1] != i:
      for j in range(i - 1, r + step, step):
        if li[j] == i:
          ret.append((i, j + 1))
          li[i-1: j + step:step] = list(reversed(li[i - 1: j + step: step]))
          break
      else:
        ret.append((1, i))
        li[:i] = list(reversed(li[:i]))
  return ret if len(ret) <= 2 else []

input()
li = [int(x) for x in input().split()]
ret = reverse(deepcopy(li), 1, len(li), 1)
if not ret:
  ret = reverse(deepcopy(li), len(li), 1, -1)
while len(ret) < 2:
  ret.append((1, 1))
for p in ret:
  print(*sorted(p))
```

{% endtab %}
{% endtabs %}

* [Level 16 : 떨어지는 개미](https://www.acmicpc.net/problem/3163)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/adhoc/BJ_3163.md/)

{% tabs %}
{% tab title='BJ_3163.md' %}

> Question

* There are n ants on a line that moves 1 grid per second
* Find kth ant that drop from a line

```txt
Input:
2
6 30 3
5 4
8 5
19 -1
22 -3
24 -2
25 6
4 35 2
5 -1
12 3
20 4
30 2

Output:
-2
2
```

> Solution

* Ants relative position doesn't change

{% endtab %}
{% tab title='BJ_3163.py' %}

```py
from sys import stdin
input = stdin.readline

for _ in range(int(input())):
  n, l, k = map(int, input().split())
  left, right = [], []
  ant = []
  for i in range(n):
    p, a = map(int, input().split())
    if a < 0: left.append(p)
    else: right.append(l - p)
    ant.append(a)
  for i in range(len(left)): left[i] = (left[i], ant[i])
  for i in range(len(right)): right[~i] = (right[~i], ant[~i])
  print(sorted(left + right)[k - 1][1])
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 3 : Transform to Chessboard](https://leetcode.com/problems/transform-to-chessboard)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/adhoc/LC_782.md/)

{% tabs %}
{% tab title='LC_782.md' %}

> Question

* Given an n x n binary grid board. In each move, swap any two rows with each other, or any two columns with each other
* Return the minimum number of moves to transform the board into a chessboard board. If impossible, return -1
* A chessboard board is a board where no 0's and no 1's are 4-directionally adjacent.

```txt
Input: board =
[[0,1,1,0],
 [0,1,1,0],
 [1,0,0,1],
 [1,0,0,1]]

Output: 2
```

> Solution

1. In a valid chess board, there are 2 and only 2 kinds of rows and one is inverse to the other
    * [ex] if there is a row 01010011 in the board, any other row must be either 01010011 or 10101100
1. Every row and column has half ones.
    * If N = 2 * K + 1, every row and every column has K ones and K + 1 zeros or K + 1 ones and K zeros

{% endtab %}
{% tab title='LC_782.py' %}

```py
def movesToChessboard(self, b):
  N = len(b)
  if any(b[0][0] ^ b[i][0] ^ b[0][j] ^ b[i][j] for i in range(N) for j in range(N)): return -1
  if not N // 2 <= sum(b[0]) <= (N + 1) // 2: return -1
  if not N // 2 <= sum(b[i][0] for i in range(N)) <= (N + 1) // 2: return -1
  col = sum(b[0][i] == i % 2 for i in range(N))
  row = sum(b[i][0] == i % 2 for i in range(N))
  if N % 2:
    if col % 2: col = N - col
    if row % 2: row = N - row
  else:
    col = min(N - col, col)
    row = min(N - row, row)
  return (col + row) // 2
```

{% endtab %}
{% endtabs %}
