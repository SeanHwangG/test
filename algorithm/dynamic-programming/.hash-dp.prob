> leetcode

* [Level 2 : Largest Divisible Subset](https://leetcode.com/problems/largest-divisible-subset)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/hash-dp/LC_368.md/)

{% tabs %}
{% tab title='LC_368.md' %}

> Question

* Find largest divisible subset s.t. every pair (answer[i], answer[j]) in this subset satisfies
  * answer[i] % answer[j] == 0, or answer[j] % answer[i] == 0

```txt
Input: nums = [1,2,3]
Output: [1,2]
```

{% endtab %}
{% tab title='LC_368.py' %}

```py
def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
  S = {-1: set()}
  for x in sorted(nums):
    S[x] = max((S[d] for d in S if x % d == 0), key = len) | {x}
  return list(max(S.values(), key=len))
```

{% endtab %}
{% endtabs %}

* [Level 2 : Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/hash-dp/LC_416.md/)

{% tabs %}
{% tab title='LC_416.md' %}

> Question

* Check whether it can be splitted into two equal sum array

```txt
Input: nums = [1,5,11,5]
Output: true
```

{% endtab %}
{% tab title='LC_416.py' %}

```py
def canPartition(nums):
  if sum(nums) & 1 == 0:
    target = sum(nums) >> 1
    dp = {0}
    for i in nums:
      dp |= {i + x for x in dp}
      if target in dp:
        return True
  return False
```

{% endtab %}
{% endtabs %}

* [Level 3 : Race Car](https://leetcode.com/problems/race-car)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/hash-dp/LC_818.md/)

{% tabs %}
{% tab title='LC_818.md' %}

> Question

* Car starts at position 0 and speed +1 on an infinite number line, can go into negative positions
* Car drives automatically according to a sequence of instructions 'A' (accelerate) and 'R' (reverse):
* When you get an instruction 'A', your car does the following:
  * position += speed, speed *= 2
* When you get an instruction 'R', your car does the following:
  * If your speed is positive then speed = -1, otherwise speed = 1
* Your position stays the same.
* [ex] After commands "AAR", your car goes to positions 0 --> 1 --> 3 --> 3, and your speed goes to 1 --> 2 --> 4 --> -1.
* Given a target position target, return length of shortest sequence of instructions to get there.

```txt
Input: target = 3
Output: 2  # AA 0 --> 1 --> 3

Input: target = 6
Output: 5  # AAARA 0 --> 1 --> 3 --> 7 --> 7 --> 6
```

> Solution

1. Go pass our target, stop and turn back
    * We take n instructions of A.
    * 1 + 2 + 4 + ... + 2 ^ (n-1) = 2 ^ n - 1
    * Then we turn back by one R instruction.
    * In the end, we get closer by n + 1 instructions.

2. Go as far as possible before pass target, stop and turn back
    * We take n - 1 instruction of A and one R.
    * Then we take m instructions of A, where m < n

{% endtab %}
{% tab title='LC_818.py' %}

```py
# Time O(TlogT)
# Space O(T)
@lru_cache(None)
def racecar(self, t: int) -> int:
  if t == 0:
    return 0
  n = t.bit_length()
  if 2 ** n - 1 == t:
    return n
  else:
    mn = self.racecar(2 ** n - 1 - t) + n + 1
    for m in range(n - 1):
      mn = min(mn, self.racecar(t - 2 ** (n - 1) + 2 ** m) + n + m + 1)
  return mn
```

{% endtab %}
{% endtabs %}

* [Level 3 : Count Unique Characters of All Substrings of a Given String](https://leetcode.com/problems/count-unique-characters-of-all-substrings-of-a-given-string)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/hash-dp/LC_828.md/)

{% tabs %}
{% tab title='LC_828.md' %}

> Question

* Let's define a function countUniqueChars(s) that returns the number of unique characters on s.
* [ex] if s = "LEETCODE" then "L", "T", "C", "O", "D" are the unique characters since they appear only once in s, 5.
* Given a string s, return the sum of countUniqueChars(t) where t is a substring of s.
* Notice that some substrings can be repeated so in this case you have to count the repeated ones too.

```txt
Input: s = "ABC"
Output: 10  # "A","B","C","AB","BC" and "ABC".

Input: s = "ABA"
Output: 8
```

{% endtab %}
{% tab title='LC_828.py' %}

```py
def uniqueLetterString(self, S: str) -> int:
  dp = {c: [-1, -1] for c in string.ascii_uppercase} # last two occurrence index for every upper characters
  res = 0
  for i, c in enumerate(S):
    k, j = dp[c]
    res += (i - j) * (j - k)
    dp[c] = [j, i]
  for c in dp:
    k, j = dp[c]
    res += (len(S) - j) * (j - k)
  return res % (10**9 + 7)
```

{% endtab %}
{% endtabs %}
