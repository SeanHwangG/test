> baekjoon

* [Level 10 : 이동하기](https://www.acmicpc.net/problem/11048)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dimension-2-path/BJ_11048.md/)

{% tabs %}
{% tab title='BJ_11048.md' %}

> Question

* Find maximum number of candy from (1, 1) to (N, M)

```txt
Input:
3 4
1 2 3 4
0 0 0 5
9 8 7 6

Output: 31
```

{% endtab %}
{% tab title='BJ_11048.py' %}

```py
n, m = map(int, input().split())
G = [list(map(int, input().split())) for _ in range(n)]
dp = [[0] * (m + 1) for i in range(n + 1)]
for i in range(1, n + 1):
  for j in range(1, m + 1):
    dp[i][j] = G[i - 1][j - 1] + max(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
print(dp[n][m])
```

{% endtab %}
{% endtabs %}

* [Level 10 : 정수 삼각형](https://www.acmicpc.net/problem/1932)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dimension-2-path/BJ_1932.md/)

{% tabs %}
{% tab title='BJ_1932.md' %}

> Question

* Given maximum sum path when you can go down or down right

```txt
Input:
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5

Output: 30
```

{% endtab %}
{% tab title='BJ_1932.js' %}

```js
let input = require('fs').readFileSync(0, 'utf-8').trim().split('\n');
let tri = input.slice(1).map(e => e.split(' ').map(e => +e));
const n = +input[0];
const dp = Array(n).fill(0).map((e, i) => Array(i + 1));
dp[0] = tri[0];
for (let i = 1; i < n; i++)
  for (let j = 0; j < i + 1; j++)
    dp[i][j] = Math.max(dp[i - 1][j] || 0, dp[i - 1][j - 1] || 0) + tri[i][j]
console.log(Math.max(...dp[n-1]));
```

{% endtab %}
{% tab title='BJ_1932.py' %}

```py
n=int(input())
G = [list(map(int,input().split())) for _ in range(n)]
for i in range(n - 2, -1, -1):
  for j in range(len(s[i])):
    s[i][j] += max(s[i + 1][j : j + 2])
print(s[0][0])
```

{% endtab %}
{% endtabs %}

* [Level 12 : 내려가기](https://www.acmicpc.net/problem/2096)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dimension-2-path/BJ_2096.md/)

{% tabs %}
{% tab title='BJ_2096.md' %}

> Question

* You can stay, or move left / right one block at a time
* Find maximum score moving down 2D map

```txt
Input:
3
1 2 3
4 5 6
4 9 0

Output: 18 6
```

{% endtab %}
{% tab title='BJ_2096.py' %}

```py
a, b, c = 0, 0, 0
A, B, C = 0, 0, 0
for i in range(int(input())):
  x, y, z = map(int, input().split())
  a, b, c = min(a, b) + x, min(a, b, c) + y, min(b, c) + z
  A, B, C = max(A, B) + x, max(A, B, C) + y, max(B, C) + z
print(max(A,B,C), min(a,b,c))
```

{% endtab %}
{% endtabs %}

* [Level 15 : 달이 차오른다, 가자.](https://www.acmicpc.net/problem/1194)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dimension-2-path/BJ_1194.md/)

{% tabs %}
{% tab title='BJ_1194.md' %}

> Question

* Given map with following symbols, find minimum distance to escape
  * 0: start position
  * 1: goal position
  * lower_alphabet: key
  * upper_alphabet: door that requires its lower alphabet key
  * \#: wall
  * .: empty

```txt
Input:
7 8
a#c#eF.1
.#.#.#..
.#B#D###
0....F.1
C#E#A###
.#.#.#..
d#f#bF.1

Output: 55
```

{% endtab %}
{% tab title='BJ_1194.py' %}

```py
from collections import deque

N, M = map(int, input().split())
G = [list(input().strip()) for _ in range(N)]
dp = [[[0]*64 for _ in range(M)] for _ in range(N)]
q = deque()

for i in range(N):
  for j in range(M):
    if G[i][j] == '0':
      q.append((i, j, 0))

while q:
  x, y, k = q.popleft()
  if G[x][y] == '1':
    print(dp[x][y][k])
    return
  for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
    nx, ny, nk = x + dx[i], y + dy[i], k
    if not (0 <= nx < N and 0 <= ny < M):
      continue
    c = G[nx][ny]
    if c.islower():
      nk |= (1<<(ord(c)-ord('a')))
    elif c.isupper() and not nk & (1<<(ord(c)-ord('a'))):
      continue
    if not dp[nx][ny][nk] and c != '#':
      q.append((nx, ny, nk))
      dp[nx][ny][nk] = dp[x][y][k] + 1
print(-1)
```

{% endtab %}
{% endtabs %}

* [Level 15 : 로봇 조종하기](https://www.acmicpc.net/problem/2169)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dimension-2-path/BJ_2169.md/)

{% tabs %}
{% tab title='BJ_2169.md' %}

> Question

* Robot can move left, right, down, find maximum sum

```txt
Input:
5 5
10 25 7 8 13
68 24 -78 63 32
12 -69 100 -29 -25
-16 -22 -57 -33 99
7 -76 -11 77 15

Output:
319
```

{% endtab %}
{% tab title='BJ_2169.py' %}

```py
N, M = map(int, input().split())
G = [list(map(int, input().split())) for _ in range(N)]
S, dp = 0, []
for i in range(M):
  S += G[0][i]
  dp.append(S)

for j in range(1, N):
  L = [dp[0] + G[j][0]] + [0] * (M - 1)
  for i in range(1, M):
    L[i] = G[j][i] + max(L[i - 1], dp[i])
  R = [0] * (M - 1) + dp[-1] + G[j][-1]
  for i in range(1, M):
    R[-i-1] = G[j][-i-1] + max(R[-i], dp[-i-1])
  for i in range(M):
    dp[i] = max(L[i], R[i])
print(dp[-1])
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 2 : Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dimension-2-path/LC_64.md/)

{% tabs %}
{% tab title='LC_64.md' %}

> Question

* find a path from top left to bottom right minimizes the sum

```txt
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
```

{% endtab %}
{% tab title='LC_64.py' %}

```py
def minPathSum(self, grid):
  r, c = len(grid), len(grid[0])
  dp = [[0 for _ in range(c)] for _ in range(r)]
  dp[0][0] = grid[0][0]
  for i in range(1, r):
    dp[i][0] = dp[i-1][0] + grid[i][0]
  for i in range(1, c):
    dp[0][i] = dp[0][i-1] + grid[0][i]
  for i in range(1, r):
    for j in range(1, c):
      dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
  return dp[-1][-1]
```

{% endtab %}
{% endtabs %}

* [Level 2 : Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dimension-2-path/LC_931.md/)

{% tabs %}
{% tab title='LC_931.md' %}

> Question

* Given 2D grid, find minium path sum
* (row, col) can go to (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1)

```txt
Input: matrix = [[2,1,3],[6,5,4],[7,8,9]]
Output: 13
```

{% endtab %}
{% tab title='LC_931.py' %}

```py
def minFallingPathSum(self, A):
  dp = A[0]
  for row in A[1:]:
    dp = [value + min(dp[max(0, c - 1) : c + 2]) for c, value in enumerate(row)]
  return min(dp)
```

{% endtab %}
{% endtabs %}

* [Level 3 : Dungeon Game](https://leetcode.com/problems/dungeon-game)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dimension-2-path/LC_174.md/)

{% tabs %}
{% tab title='LC_174.md' %}

> Question

* Return the knight's minimum initial health so that he can rescue the princess

```txt
Input: dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
Output: 7
```

{% endtab %}
{% tab title='LC_174.py' %}

```py
def calculateMinimumHP(self, G: List[List[int]]) -> int:
  m, n = len(G), len(G[0])
  dp = [[float("inf")]*(n+1) for _ in range(m+1)]
  dp[m-1][n], dp[m][n-1] = 1, 1

  for i in range(m - 1, -1, -1):
    for j in range(n - 1, -1, -1):
      dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - G[i][j], 1)

  return dp[0][0]
```

{% endtab %}
{% endtabs %}
