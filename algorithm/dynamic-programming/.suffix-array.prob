> baekjoon

* [Level 18 : 반복 부분문자열](https://www.acmicpc.net/problem/1605)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/suffix-array/BJ_1605.md/)

[//]: # (BJ_3033)

* [Level 18 : 가장 긴 문자열](https://www.acmicpc.net/problem/3033)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/suffix-array/BJ_3033.md/)

{% tabs %}
{% tab title='BJ_3033.md' %}

> Question

* Print longest string that appears twice

```txt
Input:
11
sabcabcfabc

Output: 3
```

{% endtab %}
{% tab title='BJ_3033.py' %}

```py
input()
s = input()
N = len(s)

tmp, lcp = [0] * N, [0] * N
sa = [i for i in range(N)]
r = [ord(i) for i in s]
f = lambda m: r[m] if m < N else -1

L = 1
while L <= N:
  sa.sort(key=lambda x: (f(x), f(x+L)))
  rnk = 0
  tmp[sa[0]] = rnk

  for i in range(1, N):
    if f(sa[i]) != f(sa[i-1]) or f(sa[i]+L) != f(sa[i-1]+L):
      rnk += 1
    tmp[sa[i]] = rnk

  r = tmp[:]
  L <<= 1

for i in range(N):
  r[sa[i]] = i

ans = 0

L = 0
for i in range(N):
  if r[i]:
    j = sa[r[i] - 1]
    while i + L < N and j+L<N and s[i + L] == s[j + L]:
      L += 1

    lcp[r[i]] = L
    ans = max(ans, L)
    L -= bool(L)

print(ans)
```

{% endtab %}
{% endtabs %}

* [Level 18 : uffix Array](https://www.acmicpc.net/problem/9248)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/suffix-array/BJ_9248.md/)

{% tabs %}
{% tab title='BJ_9248.md' %}

> Question

* Given banaba, print suffix array and LCP
* suffix array is defined as ordered suffix
* LCP is defined as length of common substring with previous index of suffix array

| Suffix | i   | LCP |
| ------ | --- | --- |
| a      | 6   | x   |
| ana    | 4   | 1   |
| anana  | 2   | 3   |
| banana | 1   | 0   |
| na     | 5   | 0   |
| nana   | 3   | 2   |

```txt
Input: banana

Output:
6 4 2 1 5 3
x 1 3 0 0 2
```

> Solution

* Incrementally sort (2 ** n) suffix

![BJ_9248](suffix-array/images/20210527_221330.png)

* Store rank (ascii) and next rank for faster sorting

| Index | Suffix | Rank | Next Rank |
| ----- | ------ | ---- | --------- |
| 0     | banana | 1    | 0         |
| 1     | anana  | 0    | 13        |
| 2     | nana   | 13   | 0         |
| 3     | ana    | 0    | 13        |
| 4     | na     | 13   | 0         |
| 5     | a      | 0    | 1         |

{% endtab %}
{% tab title='BJ_9248.py' %}

```py
import sys
s = sys.stdin.readline().strip()

n = len(s)
sa = [i for i in range(len(s))]
rank, ng = [0] * (n + 1), [0] * (n + 1)

for i in range(n):
  rank[i] = ord(s[i])

rank[n] = -1
t = 1

ng[sa[0]] = 0
ng[n] = -1

while t < n:
  sa.sort(key = lambda x:(rank[x], rank[min(x + t, n)]))
  for i in range(1, n):
    p, q = sa[i - 1], sa[i]
    if rank[p] != rank[q] or rank[min(p + t, n)] != rank[min(q + t, n)]:
      ng[q] = ng[p] + 1
    else:
      ng[q] = ng[p]
  t *= 2
  rank = ng[:]

lcp, k = [0] * n, 0

for i in range(n):
  if rank[i] == 0:
    continue
  j = sa[rank[i] - 1]
  while j + k < n and s[i + k] == s[j + k]:
    k += 1
  lcp[rank[i]] = k
  if k:
    k -= 1
lcp[0] = 'x'

for z in range(n):
  sa[z] += 1

print(*sa)
print(*lcp)
```

{% endtab %}
{% endtabs %}

* [Level 18 : 최장 공통 부분 문자열](https://www.acmicpc.net/problem/9249)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/suffix-array/BJ_9249.md/)

{% tabs %}
{% tab title='BJ_9249.md' %}

> Question

* Find longest common substring and it's length

```txt
Input:
yeshowmuchiloveyoumydearmotherreallyicannotbelieveit
yeaphowmuchiloveyoumydearmother

Output:
27
howmuchiloveyoumydearmother
```

{% endtab %}
{% tab title='BJ_9249.cpp' %}

```cpp
#include <bits/stdc++.h>
using namespace std;

string A, B, C;
int al, bl, idx, ans;
vector<int> g, ng, ordered, lcp, cnt, sfx;

void getsfx(string& s) {
  int p = 1;
  int n = s.size();
  int mx = max(257, n + 1);

  g.resize(n + 1); ng.resize(n + 1);
  sfx.resize(n); ordered.resize(n);

  for (int i = 0;i < n;++i) g[i] = s[i];

  for (int t = 1;t < n;t <<= 1) {
    cnt.clear(); cnt.resize(mx);
    for (int i = 0;i < n;++i) ++cnt[g[min(i + t, n)]];
    for (int i = 1;i < mx;++i) cnt[i] += cnt[i - 1];
    for (int i = n - 1;i >= 0;--i) ordered[--cnt[g[min(i + t, n)]]] = i;

    cnt.clear(); cnt.resize(mx);
    for (int i = 0;i < n;++i) ++cnt[g[i]];
    for (int i = 1;i < mx;++i) cnt[i] += cnt[i - 1];
    for (int i = n - 1;i >= 0;--i) sfx[--cnt[g[ordered[i]]]] = ordered[i];

    if (p == n) break;
    p = 1;

    auto cmp = [&](int i, int j) {
      if (g[i] == g[j]) return g[i + t] < g[j + t];
      return g[i] < g[j];
    };

    ng[sfx[0]] = 1;

    for (int i = 1;i < n;++i) {
      if (cmp(sfx[i - 1], sfx[i])) ++p,ng[sfx[i]] = ng[sfx[i - 1]] + 1;
      else ng[sfx[i]] = ng[sfx[i - 1]];
    }
    g = ng;
  }

  lcp.resize(n);
  for (int i = 0;i < n;++i) g[sfx[i]] = i;
  for (int i = 0, k = 0;i < n;++i, k = max(k - 1, 0)) {
    if (g[i] == n - 1) continue;
    for (int j = sfx[g[i] + 1];s[i + k] == s[j + k];++k);
    lcp[g[i]] = k;
  }

  for (int i = 0;i < n - 1;++i)
    if (sfx[i] < al && al < sfx[i + 1]||sfx[i+1]<al&&al<sfx[i])
      if (lcp[i] <= al)
        if (ans < lcp[i]) {
          ans = lcp[i];
          idx = sfx[i];
        }
}

int main() {
  cin.tie(NULL);cout.tie(NULL); ios::sync_with_stdio(false);
  cin >> A >> B;
  al = A.size();
  bl = B.size();
  C = A + '$' + B;
  getsfx(C);
  cout << ans<<'\n';
  cout << C.substr(idx, ans);
  return 0;
}
```

{% endtab %}
{% tab title='BJ_9249.py' %}

```py
a, b = input(), input()
s = a + " " + b
rank = [ord(i) for i in s ]
N = len(s)

sa = [i for i in range(N)]
tmp = [0] * N
f = lambda x : rank[x] if x < N else -1

length = 1

while length <= N:
  sa.sort(key=lambda x: (f(x), f(x + length)))
  p = 0
  tmp[sa[0]] = 0

  for i in range(1, N):
    if f(sa[i - 1]) != f(sa[i]) or f(sa[i - 1] + length) != f(sa[i] + length):
      p += 1
    tmp[sa[i]] = p
  rank = tmp[:]
  length <<= 1

lcp = [-1] * N

for i in range(N):
  rank[sa[i]] = i

k = 0
for i in range(N):
  if not rank[i]:
    continue
  j = sa[rank[i] - 1]
  while i+k < N and j+k < N and s[i+k] == s[j+k]:
    k += 1

  lcp[rank[i]] = k
  if k != 0:
    k -= 1

m = (0, 0)

for i, j in enumerate(lcp):
  if 0 <= sa[i-1] < len(a) and len(a)<sa[i]<len(s):
    m = max(m, (j, i))

  if 0 <= sa[i] < len(a) and len(a)<sa[i-1]<len(s):
    m = max(m, (j, i))

length, i = m
print(length)
print(s[sa[i]:sa[i] + length])
```

{% endtab %}
{% endtabs %}
