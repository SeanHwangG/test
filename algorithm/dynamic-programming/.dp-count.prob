> baekjoon

* [Level 9 : Ï†êÌîÑ](https://www.acmicpc.net/problem/1890)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/BJ_1890.md/)

{% tabs %}
{% tab title='BJ_1890.md' %}

> Question

* You should always go right or down as many times as the current column says
* When you jump once, you should not change direction
* Find the number of paths that can be moved according to the rule from the top leftmost to the bottom rightmost column

```txt
Input:
4
2 3 3 1
1 2 1 3
1 2 3 1
3 1 1 0

Output: 3
```

{% endtab %}
{% tab title='BJ_1890.py' %}

```py
n = int(input())
G = [list(map(int, input().split())) for _ in range(n)]
dp = [[0 for _ in range(n)] for _ in range(n)]
dp[0][0] = 1
for y in range(n):
  for x in range(n):
    if dp[y][x] != 0 and G[y][x] != 0:
      if y + G[y][x] < n:
        dp[y + G[y][x]][x] += dp[y][x]
      if x + G[y][x] < n:
        dp[y][x+ G[y][x]] += dp[y][x]
print(dp[-1][-1])
```

{% endtab %}
{% endtabs %}

* [Level 10 : ÎèôÎ¨ºÏõê](https://www.acmicpc.net/problem/1309)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/BJ_1309.md/)

{% tabs %}
{% tab title='BJ_1309.md' %}

> Question

* Lions live in this zoo, and when they are locked in a cage, they cannot be placed horizontally or vertically
* The zoo's trainer is troubled by the placement of the lions
* Find out how many cases we have of placing lions in a 2*N array so that the zoo trainer doesn't get a headache
* It is assumed that the number of cases in which none of the lions are placed is the number of cases

```txt
Input: 4
Output: 41
```

{% endtab %}
{% tab title='BJ_1309.py' %}

```py
n = int(input())
dp = [[0, 0, 0] for _ in range(n + 1)]
dp[1][0] = dp[1][1] = dp[1][2] = 1
for i in range(2, n + 1):
  dp[i][0] = (dp[i - 1][0] + dp[i - 1][1] + dp[i - 1][2]) % 9901
  dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % 9901
  dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % 9901

print(sum(dp[n]) % 9901)
```

{% endtab %}
{% endtabs %}

* [Level 10 : ÎèôÏ†Ñ 1](https://www.acmicpc.net/problem/2293)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/BJ_2293.md/)

{% tabs %}
{% tab title='BJ_2293.md' %}

> Question

* There are n kinds of coins. Each coin represents a different value
* Find the number of ways to use this coin so that the sum of the coins is k won

```txt
Input: 4
Output: 41
```

{% endtab %}
{% tab title='BJ_2293.py' %}

```py
N, total = map(int, input().split())
li = [int(input()) for _ in range(N)]
dp = [0] * (total + 1)
dp[0] = 1
for i in range(N):
  coin = li[i]
  for value in range(coin, total + 1):
    dp[value] += dp[value - coin]

print(dp[-1])
```

{% endtab %}
{% endtabs %}

* [Level 11 : ÌååÏù¥ÌîÑ ÏòÆÍ∏∞Í∏∞ 1](https://www.acmicpc.net/problem/17070)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/BJ_17070.md/)

{% tabs %}
{% tab title='BJ_17070.md' %}

> Question

![Ways](dp-count/images/20210417_050545.png)

* Find number of ways to connect pipe to right down
* Pipe can be turned 45 degree

```txt
Input:
6
0 0 0 0 0 0
0 1 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
Output: 13
```

{% endtab %}
{% tab title='BJ_17070.py' %}

```py
N=int(input())
R, dp=[[*map(int, input().split())] for _ in range(N)],[[[0]*3 for _ in range(N)] for _ in range(N)]
dp[0][1][0]=1
for j in range(2, N):
  if R[0][j] == 0: dp[0][j][0] = dp[0][j - 1][0]
for i in range(1, N):
  for j in range(2, N):
    if R[i][j]: continue
    if R[i][j - 1] == 0 and R[i-1][j] == 0: dp[i][j][1] = sum(dp[i-1][j-1])
    dp[i][j][0] = dp[i][j - 1][0]+dp[i][j - 1][1]
    dp[i][j][2] = dp[i - 1][j][1]+dp[i - 1][j][2]
print(sum(dp[N - 1][N - 1]))
```

{% endtab %}
{% endtabs %}

* [Level 11 : Ìï©Î∂ÑÌï¥](https://www.acmicpc.net/problem/2225)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/BJ_2225.md/)

{% tabs %}
{% tab title='BJ_2225.md' %}

> Question

* Add K integers from 0 to N and find the number of cases where the sum is N

```txt
Input: 20 2
Output: 21   # 1 19, 2 18, 3 17 ...
```

{% endtab %}
{% tab title='BJ_2225.py' %}

```py
N, K = map(int, input().split())
mod = 1000000000
table = [1] + [0] * N
for _ in range(1, K+1):
  for i in range(1, N+1):
    table[i] = (table[i] + table[i-1]) % mod
print(str(table[N]))
```

{% endtab %}
{% endtabs %}

* [Level 14 : ÏÑ†Î¨º Ï†ÑÎã¨](https://www.acmicpc.net/problem/1947)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/BJ_1947.md/)

{% tabs %}
{% tab title='BJ_1947.md' %}

> Question

* Each person recieve at least on present, find number of ways to distribute

```txt
Input: 5
Output: 44
```

{% endtab %}
{% tab title='BJ_1947.py' %}

```py
n = int(input())
a, b = 1, 0
for i in range(2, n+1) :
  a, b = b, ((i - 1) * (a + b)) % 10**9
print(b)
```

{% endtab %}
{% endtabs %}

> codeforces

* [Level 1600 : Sequence Pair Weight](https://codeforces.com/contest/1527/problem/C)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/CF_1527C.md/)

{% tabs %}
{% tab title='CF_1527C.md' %}

> Question

* weight of a sequence is defined as the number of unordered pairs of indexes (ùëñ,ùëó) (here ùëñ<ùëó) with same value (ùëéùëñ=ùëéùëó)
* given a sequence ùëé of ùëõ integers. Print the sum of the weight of all subsegments of ùëé

```txt
Input:
2
4
1 2 1 1
4
1 2 3 4

Output:
6
0
```

> Solution

* unordered pairs is accumulated as in fibonacci
* Including current position * left, right padding
* Accumulate score in dp for each number

{% endtab %}
{% tab title='CF_1527C.py' %}

```py
for _ in range(int(input())):
  N = int(input())
  li = list(map(int, input().split()))
  dp, ans = {}, 0
  for n, i in enumerate(li):
    if n not in dp: dp[n] = 0
    ans += dp[n] * (N - i)
    dp[n] += i + 1
  print(ans)
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 2 : Unique Paths II](https://leetcode.com/problems/unique-paths-ii)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/LC_63.md/)

{% tabs %}
{% tab title='LC_63.md' %}

> Question

* A robot is located at the top-left corner of a m x n grid
* The robot can only move either down or right, trying to reach the bottom-right corner of the grid
* Now consider if some obstacles are added to the grids. How many unique paths would there be?

```txt
Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
```

{% endtab %}
{% tab title='LC_63.py' %}

```py
# Time : O(N^2), Space : O(N)
def uniquePathsWithObstacles(self, G: List[List[int]]) -> int:
  if not G:
    return
  cur = [0] * len(G[0])
  cur[0] = 1 - G[0][0]
  for i in range(1, len(G[0])):
    cur[i] = cur[i-1] * (1 - G[0][i])
  for i in range(1, len(G)):
    cur[0] *= (1 - G[i][0])
    for j in range(1, len(G[0])):
      cur[j] = (cur[j-1] + cur[j]) * (1 - G[i][j])
  return cur[-1]

```

{% endtab %}
{% endtabs %}

* [Level 2 : Domino and Tromino Tiling](https://leetcode.com/problems/domino-and-tromino-tiling)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/LC_790.md/)

{% tabs %}
{% tab title='LC_790.md' %}

> Question

* Given two types of domino (I and L), find the number of ways to tile 2 * N board

```txt
Input: n = 3
Output: 5
```

{% endtab %}
{% tab title='LC_790.py' %}

```cpp
int numTilings(int N) {
  int p3 = -1, p2 = 0, p1 = 1;
  for (int n = 1; n <= N; n++) {
    int cur = (p1 * 2L + p3) % int(1e9 + 7);
    p3 = p2;
    p2 = p1;
    p1 = cur;
  }
  return p1;
}
```

{% endtab %}
{% endtabs %}

* [Level 3 : Restore The Array](https://leetcode.com/problems/restore-the-array)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/LC_1416.md/)

{% tabs %}
{% tab title='LC_1416.md' %}

> Question

* A program was supposed to print an array of integers
* Array is printed as string of digits s and all integers in array were in the range [1, k] without leading zero
* Given string s and integer k, return $ possible arrays that can be printed as s using the mentioned program
* Since answer may be very large, return it modulo 109 + 7.

```txt
Input: s = "1000", k = 10000
Output: 1

Input: s = "1000", k = 10
Output: 0

Input: s = "1317", k = 2000
Output: 8
```

{% endtab %}
{% tab title='LC_1416.py' %}

```py
def numberOfArrays(self, s: str, k: int) -> int:
  N, s = len(s), [*map(int, s)] + [math.inf]
  dp = [0] * N + [1]
  for i in range(N - 1, -1, -1):
    num, j = s[i], i + 1
    while 1 <= num <= k and j < N + 1:
      dp[i] = (dp[i] + dp[j]) % 1000000007
      num = 10 * num + s[j]
      j += 1
  return dp[0]
```

{% endtab %}
{% endtabs %}

* [Level 3 : Arithmetic Slices II - Subsequence](https://leetcode.com/problems/arithmetic-slices-ii-subsequence)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/LC_446.md/)

{% tabs %}
{% tab title='LC_446.md' %}

> Question

* Given an integer array nums, return the number of all the arithmetic subsequences of length greater than 2

```txt
Input: nums = [2,4,6,8,10]
Output: 7
```

{% endtab %}
{% tab title='LC_446.py' %}

```py
def numberOfArithmeticSlices(self, li: List[int]) -> int:
  ans = 0
  dp = defaultdict(int)
  for i in range(1, len(li)):
    for j in range(i):
      delta = li[i] - li[j]
      ans += dp[(j, delta)]
      dp[(i, delta)] += dp[(j, delta)] + 1

  return ans
```

{% endtab %}
{% endtabs %}

* [Level 3 : Distinct Subsequences II](https://leetcode.com/problems/distinct-subsequences-ii)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-count/LC_940.md/)

{% tabs %}
{% tab title='LC_940.md' %}

> Question

* count the number of distinct, non-empty subsequences of S

```txt
Input: s = "abc"
Output: 7   # "a", "b", "c", "ab", "ac", "bc", and "abc".
```

{% endtab %}
{% tab title='LC_940.py' %}

```py
def distinctSubseqII(self, S):
  res, end = 0, collections.Counter()
  for c in S:
    res, end[c] = res * 2 + 1 - end[c], res + 1
  return res % (10**9 + 7)
```

{% endtab %}
{% endtabs %}
