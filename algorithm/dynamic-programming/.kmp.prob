> baekjoon

* [Level 14 : Cubeditor](https://www.acmicpc.net/problem/1701)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/kmp/BJ_1701.md/)

{% tabs %}
{% tab title='BJ_1701.md' %}

> Question

* Outputs the longest length of string that appears at least twice in the input

```txt
Input: abcdabcabb
Output: 3  # abc abc
```

{% endtab %}
{% tab title='BJ_1701.py' %}

```py
P = input()
def getPi(st):
  j = 0
  pi = [0] * len(st)
  for i in range(1, len(pi)):
    while j > 0 and st[i] != st[j]:
      j = pi[j-1]
    if st[i] == st[j]:
      j += 1
      pi[i] = j
  return max(pi)
res = 0
for i in range(len(P)):
  res = max(getPi(P[i:]), res)
print(res)
```

{% endtab %}
{% endtabs %}

* [Level 15 : 찾기](https://www.acmicpc.net/problem/1786)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/kmp/BJ_1786.md/)

{% tabs %}
{% tab title='BJ_1786.md' %}

> Question

* Given string S, T, find all indices that T appears on S

```txt
Input: ABC ABCDAB ABCDABCDABDE
Output: ABCDABD
```

{% endtab %}
{% tab title='BJ_1786.py' %}

```py
s, p = input(),input()
a, j = [], 0
pi = [0] * len(p) # [0, 0, 0, 0, 1, 2, 0]
for i in range(1, len(p)):
  while j > 0 and p[i] != p[j]:
    j = pi[j - 1]
  if p[i] == p[j]:
    j += 1
    pi[i] =j
j = 0
for i in range(len(s)):
  while j > 0 and s[i] != p[j]:
    j = pi[j - 1]
  if s[i] == p[j]:
    if j == len(p) - 1: # match pattern
      a += [i - len(p) + 2]
      j = pi[j]
    else:
      j += 1
print(len(a), *a)
```

{% endtab %}
{% endtabs %}

* [Level 16 : 광고](https://www.acmicpc.net/problem/1305)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/kmp/BJ_1305.md/)

{% tabs %}
{% tab title='BJ_1305.md' %}

> Question

* String is rotating with repetition
* Print shortest possible strings

```txt
Input:
5
aaaaa

Output: 1
```

{% endtab %}
{% tab title='BJ_1305.py' %}

```py
N = int(input())
S = input()

pi = [0] * N
j = 0
for i in range(1, N):
  while j > 0 and S[i] != S[j]:
    j = pi[j - 1]
  if S[i] == S[j]:
    j += 1
    pi[i] = j

print(N - pi[-1])
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 1 : Check If a Word Occurs As a Prefix of Any Word in a Sentence](https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/kmp/LC_1455.md/)

{% tabs %}
{% tab title='LC_1455.md' %}

> Question

* Given a sentence that consists of some words separated by a single space, and a searchWord
* You have to check if searchWord is a prefix of any word in sentence

```txt
Input: sentence = "i love eating burger", searchWord = "burg"
Output: 4    # "burg" is prefix of "burger" which is the 4th word in the sentence.
```

{% endtab %}
{% tab title='LC_1455.cpp' %}

```cpp
int isPrefixOfWord(string sentence, string searchWord) {
  // auto sent = " " + sentence, word = " " + searchWord;
  // auto pos = sent.find(word);
  // if (pos != string::npos)
  //  return count(begin(sent), begin(sent) + pos + 1, ' ');
  auto sent = " " + sentence, word = " " + searchWord;
  int word_cnt = 0, j = 0;
  for (auto i = 0; i < sent.size() && j < word.size(); ++i) {
    word_cnt += sent[i] == ' ';
    if (sent[i] == word[j])
      ++j;
    else
      j = sent[i] == word[0] ? 1 : 0;
  }
  return j == word.size() ? word_cnt : -1;
}
```

{% endtab %}
{% tab title='LC_1455.py' %}

```py
def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:
  for i, w in enumerate(sentence.split(' '), 1):
    if w.startswith(searchWord):
      return i
  return -1
```

{% endtab %}
{% endtabs %}

* [Level 1 : Implement strStr()](https://leetcode.com/problems/implement-strstr)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/kmp/LC_28.md/)

{% tabs %}
{% tab title='LC_28.md' %}

> Question

* Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack

```txt
Input: haystack = "hello", needle = "ll"
Output: 2
```

{% endtab %}
{% tab title='LC_28.cpp' %}

```cpp
class Solution {
public:
  int strStr(string haystack, string needle) {
    int m = haystack.size(), n = needle.size();
    if (!n)
      return 0;
    vector<int> lps = kmpProcess(needle);
    for (int i = 0, j = 0; i < m;) {
      if (haystack[i] == needle[j])
        i++, j++;
      if (j == n)
        return i - j;
      if (i < m && haystack[i] != needle[j])
        j ? j = lps[j - 1] : i++;
    }
    return -1;
  }
private:
  vector<int> kmpProcess(string needle) {
    int n = needle.size();
    vector<int> lps(n, 0);
    for (int i = 1, len = 0; i < n;) {
      if (needle[i] == needle[len]) lps[i++] = ++len;
      else if (len)                 len = lps[len - 1];
      else                          lps[i++] = 0;
    }
    return lps;
  }
};
```

{% endtab %}
{% tab title='LC_28.py' %}

```py
def strStr(self, haystack: str, needle: str) -> int:
  concat = needle + '#' + haystack
  b, suffix = 0, [0]
  for i in range(1, len(concat)):
    while b > 0 and concat[i] != concat[b]:
      b = suffix[b - 1]
    if concat[b] == concat[i]:
      b += 1
    else:
      b = 0
    suffix.append(b)

  # 01000120 : suffix
  # ll#hello : concat
  n = len(needle)
  if n == 0:
    return n
  for i in range(n + 1, len(suffix)):
    if suffix[i] == n:
      return i - 2 * n
  return -1
```

{% endtab %}
{% endtabs %}

* [Level 3 : Longest Happy Prefix](https://leetcode.com/problems/longest-happy-prefix)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/kmp/LC_1392.md/)

{% tabs %}
{% tab title='LC_1392.md' %}

> Question

* A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself)
* Given a string s, return longest happy prefix of s, empty string "" if no such prefix exists

```txt
Input: s = "level"
Output: "l"

Input: s = "ababab"
Output: "abab"
```

{% endtab %}
{% tab title='LC_1392.py' %}

```py
def longestPrefix(self, s: str) -> str:
  lps = [0] * len(s)
  for i in range(1, len(s)):
    t = lps[i-1]
    while t and s[t] != s[i]:
      t = lps[t-1]
    if s[t] == s[i]:
      t += 1
    lps[i] = t
  return s[:lps[-1]]
```

{% endtab %}
{% endtabs %}

* [Level 3 : Find All Good Strings](https://leetcode.com/problems/find-all-good-strings)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/kmp/LC_1397.md/)

{% tabs %}
{% tab title='LC_1397.md' %}

> Question

* Given strings s1 and s2 of size n and the string evil, return the number of good strings.
* good string has size n, alphabetically greater than or equal to s1, alphabetically smaller than or equal to s2
  * and it does not contain the string evil as a substring. Since the answer can be a huge number, return MOD 10^9 + 7

```txt
Input: n = 2, s1 = "aa", s2 = "da", evil = "b"
Output: 51

Input: n = 8, s1 = "leetcode", s2 = "leetgoes", evil = "leet"
Output: 0

Input: n = 2, s1 = "gx", s2 = "gz", evil = "x"
Output: 2
```

{% endtab %}
{% tab title='LC_1397.py' %}

```py
from functools import lru_cache

def failure(pat):
  res = [0]
  i, target = 1, 0
  while i < len(pat):
    if pat[i] == pat[target]:
      target += 1
      res += target,
      i += 1
    elif target:
      target = res[target-1]
    else:
      res += 0,
      i += 1
  return res

class Solution:
  def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:
    f = failure(evil)
    @lru_cache(None)
    def dfs(idx, max_matched = 0, lb = True, rb = True):
      ''' idx: current_idx_on_s1_&_s2, max_matched: nxt_idx_to_match_on_evil,
          lb, rb: is_left_bound, is_right_bound '''
      if max_matched == len(evil): return 0  # evil found, break
      if idx == n: return 1  # base case

      l, r = s1[idx] if lb else 'a', s2[idx] if rb else 'z'  # valid left, right bound
      res, cands = 0, [chr(i) for i in range(ord(l), ord(r) + 1)]
      for i, c in enumerate(cands):
        nxt_matched = max_matched
        while evil[nxt_matched] != c and nxt_matched:
          nxt_matched = f[nxt_matched - 1]
        res += dfs(idx + 1, nxt_matched + (c == evil[nxt_matched]),
               lb = (lb and i == 0), rb = (rb and i == len(cands) - 1))
      return res

    return dfs(0) % (10 ** 9 + 7)
```

{% endtab %}
{% endtabs %}

* [Level 3 : Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/kmp/LC_214.md/)

{% tabs %}
{% tab title='LC_214.md' %}

> Question

* Given a string s. You can convert s to a palindrome by adding characters in front of it
* Return shortest palindrome you can find by performing this transformation.

```txt
Input: s = "aacecaaa"
Output: "aaacecaaa"

Input: s = "abcd"
Output: "dcbabcd"
```

{% endtab %}
{% tab title='LC_214.cpp' %}

```cpp
string shortestPalindrome(string s) {
  string rev_s = s;
  reverse(rev_s.begin(), rev_s.end());
  string l = s + "#" + rev_s;
  vector<int> p(l.size(), 0);
  for (int i = 1; i < l.size(); i++) {
    int j = p[i - 1];
    while (j > 0 && l[i] != l[j])
      j = p[j - 1];
    p[i] = (j += l[i] == l[j]);
  }
  return rev_s.substr(0, s.size() - p[l.size() - 1]) + s;
}
```

{% endtab %}
{% tab title='LC_214.py' %}

```py
def shortestPalindrome(self, s):
  r = s[::-1]
  for i in range(len(s) + 1):
    if s.startswith(r[i:]):
      return r[:i] + s
```

{% endtab %}
{% endtabs %}
