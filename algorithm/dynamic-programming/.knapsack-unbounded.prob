> leetcode

* [Level 2 : Coin Change](https://leetcode.com/problems/coin-change)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/knapsack-unbounded/LC_322.md/)

{% tabs %}
{% tab title='LC_322.md' %}

> Question

* Given an coins representing coins of different denominations and an integer amount representing a total amount of money
* Return fewest # coins that you need to make up that amount. If cannot be made up by any combination of coins, return -1

```txt
Input: coins = [1,2,5], amount = 11
Output: 3
```

{% endtab %}
{% tab title='LC_322.cpp' %}

```cpp
int coinChange(vector<int>& coins, int amount) {
  sort(coins.begin(), coins.end());
  vector<int> dp(amount + 1, -1);
  dp[0] = 0;
  for (int i = 1; i <= amount; i++){
    int temp = INT_MAX;
    for (int coin: coins){
      if (coin > i) break;
      temp = min(temp, (dp[i - coin] == -1? temp: dp[i - coin] + 1));
    }
    dp[i] = (temp != INT_MAX? temp: -1);
  }
  return dp[amount];
}
```

{% endtab %}
{% tab title='LC_322.py' %}

```py
def coinChange(self, coins: 'List[int]', amount: 'int') -> 'int':
  dp = [0] + [float('inf') for i in range(amount)]
  for i in range(1, amount+1):
    for coin in coins:
      if i - coin >= 0:
        dp[i] = min(dp[i], dp[i-coin] + 1)
  if dp[-1] == float('inf'):
    return -1
  return dp[-1]
```

{% endtab %}
{% endtabs %}

* [Level 2 : Integer Break](https://leetcode.com/problems/integer-break)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/knapsack-unbounded/LC_343.md/)

{% tabs %}
{% tab title='LC_343.md' %}

> Question

* Given an integer n, break it into sum of k positive integers, where k >= 2, and maximize product of those integers
* Return the maximum product you can get

```txt
Input: n = 10
Output: 36  # 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
```

{% endtab %}
{% tab title='LC_343.py' %}

```py
def integerBreak(self, n: int) -> int:
  case = [0, 0, 1, 2, 4, 6, 9]
  if n < 7:
    return case[n]
  dp = case + [0] * (n - 6)
  for i in range(7, n + 1):
    dp[i] = 3 * dp[i - 3]
  return dp[-1]
```

{% endtab %}
{% endtabs %}

* [Level 2 : Coin Change 2](https://leetcode.com/problems/coin-change-2)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/knapsack-unbounded/LC_518.md/)

{% tabs %}
{% tab title='LC_518.md' %}

> Question

* Given an integer coins representing coins of different denominations and integer amount representing total money
* Return # combinations that make up that amount
* If that amount of money cannot be made up by any combination of the coins, return 0.
* Have an infinite number of each kind of coin.

```txt
Input: amount = 5, coins = [1,2,5]
Output: 4

Input: amount = 10, coins = [10]
Output: 1
```

{% endtab %}
{% tab title='LC_518.py' %}

```py
def change(self, amount: int, coins: List[int]) -> int:
  dp = [1] + [0] * amount
  for c in coins:
    for i in range(c, amount + 1):
      dp[i] += dp[i-c]
  return dp[amount]
```

{% endtab %}
{% endtabs %}
