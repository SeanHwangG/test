> baekjoon

* [Level 11 : íŠ¸ë¦¬ì™€ ì¿¼ë¦¬](https://www.acmicpc.net/problem/15681)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/tree/BJ_15681.md/)

{% tabs %}
{% tab title='BJ_15681.md' %}

> Question

* Tree with Root and Query number is given
* For each query find number of children

```txt
Input:
Output:
```

{% endtab %}
{% tab title='BJ_15681.py' %}

```py
import sys
sys.setrecursionlimit(10 ** 9)
input = sys.sdin.readline

N, R, Q = list(map(int,input().split()))
G = [[] for i in range(N + 1)]
dp = [0] * (N + 1)
for i in range(N-1):
  a, b = map(int, input().split())
  G[a].append(b)
  G[b].append(a)

def dfs(n):
  dp[n] = 1
  for node in G[n]:
    if not dp[node]:
      dfs(node)
      dp[n] += dp[node]

dfs(R)
for i in range(Q):
  print(dp[int(input())])
```

{% endtab %}
{% endtabs %}

* [Level 13 : ì‚¬íšŒë§ ì„œë¹„ìŠ¤(SNS)](https://www.acmicpc.net/problem/2533)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/tree/BJ_2533.md/)

{% tabs %}
{% tab title='BJ_2533.md' %}

> Question

* A friendship tree is given
* Non-early adopters only accept this idea when all their friends are early adopters
* Find the minimum number of early adopters that all individuals need to accommodate new ideas

```txt
Input:
8
1 2
1 3
1 4
2 5
2 6
4 7
4 8

Output: 3
```

{% endtab %}
{% tab title='BJ_2533.py' %}

```py
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10**9)
def dfs(cur, visited):
  visited.add(cur)
  dp[cur][0]=1
  dp[cur][1]=0
  for adj in G[cur]:
    if adj not in visited:
      dfs(adj, visited)
      dp[cur][0] += dp[adj][1]
      dp[cur][1] += max(dp[adj][0],dp[adj][1])

N=int(input())
G=[[] for _ in range(N)]
for _ in range(N-1):
  u,v=map(int,input().split())
  G[u - 1].append(v - 1)
  G[v - 1].append(u - 1)
dp=[[0,0] for _ in range(N)] # contain / not
dfs(0, set())
print(dp)
print(N-max(dp[0][0], dp[0][1]))
```

{% endtab %}
{% endtabs %}

* [Level 15 : ìš°ìˆ˜ ë§ˆì„](https://www.acmicpc.net/problem/1949)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/tree/BJ_1949.md/)

{% tabs %}
{% tab title='BJ_1949.md' %}

> Question

* Given Tree with weight in vertices
* Find sum of maximum independent set that maximize sum weight

```txt
Input:
7
1000 3000 4000 1000 2000 2000 7000
1 2
2 3
4 3
4 5
6 2
6 7

Output: 14000
```

{% endtab %}
{% tab title='BJ_1949.py' %}

```py
import sys
input = sys.stdin.readline
sys.setrecursionlimit(1000000000)

N = int(input())
V = [0] + list(map(int,input().split()))
G = [[] for i in range(N + 1)]
for i in range(N - 1):
  a, b = map(int, input().split())
  G[a].append(b)
  G[b].append(a)
dp = [[0, 0] for i in range(N + 1)] # dp[v][0]: without v, dp[v][1]: with v

def dfs(u, p):
  dp[u][1] = V[u]
  for v in G[u]:
    if v == p: continue
    dfs(v, u)
    dp[u][0] += max(dp[v][0], dp[v][1])
    dp[u][1] += dp[v][0]

dfs(1, 0)
print(max(dp[1]))
```

{% endtab %}
{% endtabs %}

* [Level 15 : íŠ¸ë¦¬ì˜ ë…ë¦½ì§‘í•©](https://www.acmicpc.net/problem/2213)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/tree/BJ_2213.md/)

{% tabs %}
{% tab title='BJ_2213.md' %}

> Question

* Given Tree with weight in vertices
* Find maximum independent set that maximize sum weight

```txt
Input:
7
10 30 40 10 20 20 70
1 2
2 3
4 3
4 5
6 2
6 7

Output:
140
1 3 5 7
```

{% endtab %}
{% tab title='BJ_2213.py' %}

```py
import sys
input = sys.stdin.readline
sys.setrecursionlimit(1000000000)

N = int(input())
V = [0] + list(map(int,input().split()))
G = [[] for i in range(N + 1)]
for i in range(N - 1):
  a, b = map(int, input().split())
  G[a].append(b)
  G[b].append(a)
dp = [[0, 0] for i in range(N + 1)] # dp[v][0]: without v, dp[v][1]: with v

def dfs(u, p):
  dp[u][1] = V[u]
  for v in G[u]:
    if v == p: continue
    dfs(v, u)
    dp[u][0] += max(dp[v][0], dp[v][1])
    dp[u][1] += dp[v][0]

def track(u, p, last):
  if not last:
    if dp[u][0] < dp[u][1]:
      l.append(u)
      last = True
  else:
    last = False
  for v in G[u]:
    if v != p:
      track(v, u, last)

dfs(1, 0)
print(max(dp[1]))

l = []
track(1, 0, False)
print(*sorted(l))
```

{% endtab %}
{% endtabs %}

* [Level 17 : Party at Hali-Bula](https://www.acmicpc.net/problem/6272)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/tree/BJ_6272.md/)

{% tabs %}
{% tab title='BJ_6272.md' %}

* employee is not invited when his boss is also invited
* a single line containing a number indicating the maximum number of guests with the required condition
* and a word Yes or No, whether the list of guests is unique in that case

```txt
Input:
6
Jason
Jack Jason
Joe Jack
Jill Jason
John Jack
Jim Jill
2
Ming
Cho Ming
0

Output:
4 Yes
1 No
```

{% endtab %}
{% tab title='BJ_6272.cpp' %}

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, dp[200][2], choice[200][2];
vector<int> child[200];

int solve(int here, bool with_boss){
  int &ret = dp[here][with_boss];
  if(ret != -1) return ret;

  int sum0 = 0, sum1 = 1;
  for(int &there : child[here]){ // don't pick
    sum0 += solve(there, 0);
    sum1 += solve(there, 1);
  }
  if(with_boss) sum1 = -1;
  choice[here][with_boss] = (sum0 == sum1 ? 2 : (sum0 > sum1 ? 0 : 1));
  return ret = max(sum0, sum1);
}

bool reconstruct(int here, bool with_boss){
  if(choice[here][with_boss] == -1) return 0;
  if(choice[here][with_boss] == 2) return 1;
  for(int &there : child[here])
    if (reconstruct(there, choice[here][with_boss])) return true;
  return false;
}

int main(){
  ios_base::sync_with_stdio(0); cin.tie(0);

  while ((cin >> n)) {
    if (n == 0) break;
    map<string, int> name;
    for(int i = 0; i< 200; ++i)
      child[i].clear();
    memset(dp, -1, sizeof(dp));
    memset(choice, -1, sizeof(choice));

    string s1, s2;
    cin >> s1;
    name[s1] = 0;
    int k = 0;

    for(int i=1; i<n; ++i){
      cin >> s1 >> s2;
      if(!name.count(s1)) name[s1] = ++k;
      if(!name.count(s2)) name[s2] = ++k;
      child[name[s2]].push_back(name[s1]);
    }
    cout << solve(0, 0) << ' ';
    cout << (reconstruct(0,0) ? "No" : "Yes") << '\n';
  }
}
```

{% endtab %}
{% endtabs %}

> codeforces

* [Level 1600 : Parsa's Humongous Tree](https://codeforces.com/contest/1528/problem/A)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/tree/CF_1528A.md/)

{% tabs %}
{% tab title='CF_1528A.md' %}

> Question

* assign a number ğ‘ğ‘£ (ğ‘™ğ‘£ â‰¤ ğ‘ğ‘£ â‰¤ ğ‘Ÿğ‘£) to each vertex ğ‘£ st sum of |ğ‘ğ‘¢âˆ’ğ‘ğ‘£| over all edges (ğ‘¢,ğ‘£) of tree is maximized

```txt
Input:
3
2
1 6
3 8
1 2
3
1 3
4 6
7 9
1 2
2 3
6
3 14
12 20
12 19
2 12
10 17
3 17
3 2
6 5
1 5
2 6
4 6

Output:
7
8
62
```

{% endtab %}
{% tab title='CF_1528A.py' %}

```cpp
// Time : O(N)
#include <bits/stdc++.h>
using namespace std;
int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  int tt; cin >> tt;
  while (tt--) {
    int n; cin >> n;
    vector<vector<int>> V(n, vector<int>(2));
    for (int i = 0; i < n; i++)
      for (int j = 0; j < 2; j++)
        cin >> V[i][j];
    vector<vector<int>> G(n);
    for (int i = 0; i < n - 1; i++) {
      int u, v; cin >> u >> v;
      --u; --v;
      G[u].push_back(v);
      G[v].push_back(u);
    }
    vector<vector<long long>> dp(n, vector<long long>(2, -1));
    function<void(int, int)> dfs = [&](int v, int pr) {
      dp[v][0] = dp[v][1] = 0;
      for (int u : G[v]) {
        if (u == pr) continue;
        dfs(u, v);
        for (int x = 0; x < 2; x++)
          dp[v][x] += max(dp[u][0] + abs(V[v][x] - V[u][0]), dp[u][1] + abs(V[v][x] - V[u][1]));
      }
    };
    dfs(0, -1);
    cout << max(dp[0][0], dp[0][1]) << '\n';
  }
  return 0;
}
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 2 : Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/tree/LC_95.md/)

{% tabs %}
{% tab title='LC_95.md' %}

> Question

* Given an integer n, return all the structurally unique BST's, which has exactly n nodes of unique values from 1 to n

```txt
Input: n = 3
Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
```

{% endtab %}
{% tab title='LC_95.py' %}

```py
def node(val, left, right):
  node = TreeNode(val)
  node.left, node.right = left, right
  return node

def generateTrees(self, last, first=1):
  return [node(root, left, right)
          for root in range(first, last+1)
          for left in self.generateTrees(root-1, first)
          for right in self.generateTrees(last, root+1)] or [None]
```

{% endtab %}
{% endtabs %}

* [Level 3 : Kth Ancestor of a Tree Node](https://leetcode.com/problems/kth-ancestor-of-a-tree-node)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/tree/LC_1483.md/)

{% tabs %}
{% tab title='LC_1483.md' %}

> Question

* Given a tree with n nodes from 0 (root) to n-1 in form of a parent array where parent[i] is parent of node i
* Implement getKthAncestor(int node, int k) to return k-th ancestor of given node (-1 if no such ancestor)

```txt
Input:
["TreeAncestor","getKthAncestor","getKthAncestor","getKthAncestor"]
[[7,[-1,0,0,1,1,2,2]],[3,1],[5,2],[6,3]]

Output: [null,1,0,-1]
```

> Solution

* A is the parent in 1 step
* Based on this, we can find the parent in 2 steps, ... parent in 4 steps

{% endtab %}
{% tab title='LC_1483.py' %}

```py
step = 15
def __init__(self, n, A):
  A = dict(enumerate(A))
  jump = [A]
  for s in range(self.step):
    B = {}
    for i, a in A.items():
      if a in A:
        B[i] = A[a]
    jump.append(B)
    A = B
  self.jump = jump

def getKthAncestor(self, x, k):
  step = self.step
  while k > 0 and x > -1:
    if k >= 1 << step:
      x = self.jump[step].get(x, -1)
      k -= 1 << step
    else:
      step -= 1
  return x
```

{% endtab %}
{% endtabs %}
