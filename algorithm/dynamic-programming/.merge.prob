> baekjoon

* [Level 17 : 전구](https://www.acmicpc.net/problem/2449)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/merge/BJ_2449.md/)

{% tabs %}
{% tab title='BJ_2449.md' %}

> Question

* When change a number all adjacent same number are changed
* Print minimum number of change so that all elemenet changes to same number

```txt
Input:
10 3
1 1 2 3 3 3 2 2 1 1

Output: 2
```

{% endtab %}
{% tab title='BJ_2449.py' %}

```py
n,k = map(int ,input().split())
li = [*map(int, input().split())]
dp = [[0 for i in range(n)] for j in range(n)]

for i in range(n):
  for j in range(i-1, -1, -1):
    dp[j][i] = 1<<30
    for k in range(j, i):
      dp[j][i] = min(dp[j][i], dp[j][k] + dp[k + 1][i] + (li[j] != li[k + 1]))
print(dp[0][-1])
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 2 : Guess Number Higher or Lower II](https://leetcode.com/problems/guess-number-higher-or-lower-ii)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/merge/LC_375.md/)

{% tabs %}
{% tab title='LC_375.md' %}

> Question

* We are playing the Guessing Game. The game will work as follows:
  * I pick a number between 1 and n
  * You guess a number
  * If you guess the right number, you win the game
  * If you guess the wrong number, then I will tell you whether picked number is higher or lower, and will continue guessing
  * Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game

```txt
Input: 10
Output: 16  # Guess 7 first then 9 or (3, 5)
```

{% endtab %}
{% tab title='LC_375.py' %}

```py
def getMoneyAmount(self, n: int) -> int:
  @lru_cache(maxsize=None)
  def recur(l, r):
    if l >= r: return 0
    return min(i + max(recur(l, i - 1), recur(i + 1, r)) for i in range(l, r + 1))
  return recur(1, n)
```

{% endtab %}
{% endtabs %}

* [Level 3 : Burst Balloons](https://leetcode.com/problems/burst-balloons)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/merge/LC_312.md/)

{% tabs %}
{% tab title='LC_312.md' %}

> Question

* burst gives nums[left] \* nums[i] \* nums[right] point

```txt
Input: nums = [3,1,5,8]
Output: 167
```

{% endtab %}
{% tab title='LC_312.py' %}

```py
def maxCoins(self, li):
  li = [1] + li + [1]
  n = len(li)
  dp = [[0] * n for _ in range(n)]        # dp[i][j] coins obtained from balloons between index i and j
  for gap in range(2, n):
    for i in range(n - gap):
      j = i + gap
      for k in range(i+1, j):             # k is last balloon index
        dp[i][j] = max(dp[i][j], li[i] * li[k] * li[j] + dp[i][k] + dp[k][j])
  return dp[0][n-1]
```

{% endtab %}
{% endtabs %}

* [Level 3 : Remove Boxes](https://leetcode.com/problems/remove-boxes)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/merge/LC_546.md/)

{% tabs %}
{% tab title='LC_546.md' %}

> Question

* Given boxes with different colors represented by different positive numbers
* repeat until there is no box left
* Each time you can choose some continuous boxes with the same color, remove them and get k * k points
* Return the maximum points you can get

```txt
Input: boxes = [1,3,2,2,2,3,4,3,1]
Output: 23
```

{% endtab %}
{% tab title='LC_546.py' %}

```py
def removeBoxes2(self, boxes: List[int]) -> int:
  @lru_cache(None)
  def dp(i, j, k):
    if i > j:
      return 0

    while i + 1 <= j and boxes[i + 1] == boxes[i]:
      i += 1; k += 1

    res = (k + 1) * (k + 1) + dp(i + 1, j, 0)
    for t in range(i + 1, j + 1):
      if boxes[t] == boxes[i] and boxes[t - 1] != boxes[i]:
        res = max(res, dp(i + 1, t - 1, 0) + dp(t, j, k + 1))
    return res

  return dp(0, len(boxes) - 1, 0)
```

{% endtab %}
{% endtabs %}

* [Level 3 : Super Egg Drop](https://leetcode.com/problems/super-egg-drop)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/merge/LC_887.md/)

{% tabs %}
{% tab title='LC_887.md' %}

> Question

* Given K eggs, and you have access to a building with N floors from 1 to N
* What is the minimum number of moves that you need to know with certainty what F

```txt
Input: k = 2, n = 6
Output: 3
```

{% endtab %}
{% tab title='LC_887.cpp' %}

```cpp
// Time: O(KlogN), Space: O(K)
int superEggDrop(int K, int N) {
  vector<int> dp(K + 1, 0);
  int m;
  for (m = 0; dp[K] < N; m++)
    for (int k = K; k > 0; --k)
      dp[k] += dp[k - 1] + 1;
  return m;
}
```

{% endtab %}
{% tab title='LC_887.py' %}

```py
def superEggDrop(self, K: int, N: int) -> int:
  dp = [[0] * (K + 1) for i in range(N + 1)]
  for m in range(1, N + 1):
    for k in range(1, K + 1):
      dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1
    if dp[m][K] >= N: return m
```

{% endtab %}
{% endtabs %}
