> baekjoon

* [Level 6 : Four Squares](https://www.acmicpc.net/problem/17626)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-dimension-1/BJ_17626.md/)

{% tabs %}
{% tab title='BJ_17626.md' %}

> Question

* Given N, find minimum number of squares to generate N

```txt
Input: 25
Output: 1
```

{% endtab %}
{% tab title='BJ_17626.py' %}

```py
n = int(input())
dp = [0] + [float('inf')] * n
for n in range(n + 1):
  for root in range(int(n ** 0.5 + 1)):
    dp[n] = min(dp[n], dp[n - root ** 2] + 1)
print(dp[-1])
```

{% endtab %}
{% endtabs %}

* [Level 7 : 연속부분최대곱](https://www.acmicpc.net/problem/2670)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-dimension-1/BJ_2670.md/)

{% tabs %}
{% tab title='BJ_2670.md' %}

> Question

* When there are N mistakes, find where the product of one or more consecutive numbers is maximum, and print the product

```txt
Input:
8
1.1
0.7
1.3
0.9
1.4
0.8
0.7
1.4

Output: 1.638   # 1.3 * 0.9 * 1.4
```

{% endtab %}
{% tab title='BJ_2670.py' %}

```py
n = int(input())
li = [float(input()) for _ in range(n)]
dp = []
for n in li:
  if len(dp) and dp[-1] > 1:
    dp.append(dp[-1] * n)
  else:
    dp.append(n)
print(f"{max(dp):.3f}")
```

{% endtab %}
{% endtabs %}

* [Level 8 : 1로 만들기](https://www.acmicpc.net/problem/1463)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-dimension-1/BJ_1463.md/)

{% tabs %}
{% tab title='BJ_1463.md' %}

> Question

* Divide by 3 or 2 (only divisible) or subtract 1
* Find minimum operation

```txt
Input: 10
Output: 3
```

{% endtab %}
{% tab title='BJ_1463.py' %}

```py
n = int(input()) + 1
d = [0] * n
for i in range(2, n):
  d[i] = min(d[i // 2] + i % 2, d[i // 3] + i % 3) + 1
print(d[-1])
```

{% endtab %}
{% endtabs %}

* [Level 8 : 제곱수의 합](https://www.acmicpc.net/problem/1699)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-dimension-1/BJ_1699.md/)

{% tabs %}
{% tab title='BJ_14501.md' %}

> Question

* Find minimum square number that sums to N

```txt
Input: 7
Output: 4  # 4 + 1 + 1 + 1
```

{% endtab %}
{% tab title='BJ_14501.py' %}

```py
n = int(input())
dp = [0]*(n+1)
for i in range(1, n+1):
  dp[i] = i
  j = 1
  while j*j <= i:
    if dp[i] > dp[i-j*j]+1:
      dp[i] = dp[i-j*j]+1
    j += 1
print(dp[n])
```

{% endtab %}
{% endtabs %}

* [Level 8 : 1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-dimension-1/BJ_9095.md/)

{% tabs %}
{% tab title='BJ_9095.md' %}

> Question

* Given an integer n, find the number of ways to represent n as the sum of 1, 2, and 3

```txt
Input:
3
4
7
10

Output:
7
44
274
```

{% endtab %}
{% tab title='BJ_9095.py' %}

```py
dp = [1, 1, 2]
for n in range(3, 11):
  dp.append(dp[n-1] + dp[n-2] + dp[n-3])
for i in range(int(input())):
  print(dp[int(input())])
```

{% endtab %}
{% endtabs %}

* [Level 8 : 파도반 수열](https://www.acmicpc.net/problem/9461)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-dimension-1/BJ_9461.md/)

{% tabs %}
{% tab title='BJ_9461.md' %}

> Question

![BJ_9461](dp-dimension-1/images/20210228_170413.png)

* Find length of Nth triangle

```txt
Input:
2
6
12

Output:
3
6
```

{% endtab %}
{% tab title='BJ_9461.py' %}

```py
N = int(input())
dp = [0, 1, 1]
for i in range(2, 102):
  dp.append(dp[-1] + dp[-3])

for _ in range(N):
  print(dp[int(input())])
```

{% endtab %}
{% endtabs %}

* [Level 10 : 타일 채우기](https://www.acmicpc.net/problem/2133)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-dimension-1/BJ_2133.md/)

{% tabs %}
{% tab title='BJ_2133.md' %}

> Question

* Count number of ways to fill 3 x N tile using 2 x 1 and 1 x 2

```txt
Input: 2
Output: 3
```

{% endtab %}
{% tab title='BJ_2133.py' %}

```py
L = [1,0,3] + [0] * 40
for i in range(4,40,2):
  L[i] = 4 * L[i-2] - L[i-4]
print(L[int(input())])
```

{% endtab %}
{% endtabs %}

* [Level 10 : 동전 2](https://www.acmicpc.net/problem/2294)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-dimension-1/BJ_2294.md/)

{% tabs %}
{% tab title='BJ_2294.md' %}

> Question

* There are n kinds of coins. use these coins in moderation so that the sum of the coins is k won
* In doing so, we try to minimize the number of coins

```txt
Input:
3 15
1
5
12

Output: 3
```

{% endtab %}
{% tab title='BJ_2294.py' %}

```py
n, k = map(int, input().split())

memo = [0] + [10001] * k
for _ in range(n):
  coin = int(input())
  for i in range(coin, k + 1):
    memo[i] = min(memo[i], memo[i - coin] + 1)
print(memo[k] if memo[k] != 10001 else -1)
```

{% endtab %}
{% endtabs %}

* [Level 10 : 전깃줄](https://www.acmicpc.net/problem/2565)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-dimension-1/BJ_2565.md/)

{% tabs %}
{% tab title='BJ_2565.md' %}

> Question

* Print minimum number of lines you have to remove so that no line are crossing each other

```txt
Input:
8
1 8
3 9
2 2
4 1
6 4
10 10
9 7
7 6

Output: 3
```

{% endtab %}
{% tab title='BJ_2565.py' %}

```py
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
arr.sort(key=lambda  x: x[0])
dp = [0] * 501
for s, d in arr:
  dp[d] = max(dp[:d]) + 1
print(N - max(dp))
```

{% endtab %}
{% endtabs %}
