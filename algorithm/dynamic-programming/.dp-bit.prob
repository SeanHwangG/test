> baekjoon

* [Level 15 : 발전소](https://www.acmicpc.net/problem/1102)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-bit/BJ_1102.md/)

{% tabs %}
{% tab title='BJ_1102.md' %}

> Question

* There are N towers, and it costs G[a][b] to fix tower b from a
* Given tower status, print minimum cost to fix all towers

```txt
Input:
3
0 10 11
10 0 12
12 13 0
YNN
3

Output: 21
```

{% endtab %}
{% tab title='BJ_1102.py' %}

```py
def search(c, f):
  if c >= p: return 0
  if dp[f] != -1: return dp[f]
  dp[f] = 1 << 30
  for i in range(len(G)):
    if not (f & 1 << i): continue
    for j in range(len(G)):
      if i != j and not (f & 1<<j):
        dp[f] = min(dp[f], G[i][j] + search(c + 1, f | 1<<j))
  return dp[f]

G = [[*map(int, input().split())] for i in range(int(input()))]
f = c = 0
for s in input()[::-1]:
  f = (f << 1) + (s == 'Y')
  c += s == 'Y'
p = int(input())
if c == 0 and p!=0:
  print(-1)
else:
  dp = [-1] * 65536
  r = search(c, f)
  print(-1 if r == 1 << 30 else r)
```

{% endtab %}
{% endtabs %}

* [Level 15 : 계단 수](https://www.acmicpc.net/problem/1562)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-bit/BJ_1562.md/)

{% tabs %}
{% tab title='BJ_1562.md' %}

> Question

* Count number of digits under N where every consecutive digits are differed by 1

```txt
Input: 10
Output: 1
```

{% endtab %}
{% tab title='BJ_1562.py' %}

```py
n = int(input())

dp = [[[0] * 10 for _ in range(n + 1)] for _ in range(2 ** 10)] # dp[bit_visited][current][height]
mod = 1000000000
for i in range(1, 10):
  dp[1 << i][1][i] = 1

for i in range(2, n + 1):
  for j in range(10):
    for k in range(2 ** 10):
      if j < 9:
        dp[k | 1 << j][i][j] += (dp[k][i - 1][j + 1]) % mod
      if j > 0:
        dp[k | 1 << j][i][j] += (dp[k][i - 1][j - 1]) % mod

print(sum(dp[-1][-1]) % mod)
```

{% endtab %}
{% endtabs %}

* [Level 16 : 박성원](https://www.acmicpc.net/problem/1086)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-bit/BJ_1086.md/)

{% tabs %}
{% tab title='BJ_1086.md' %}

> Question

* Given N and N numbers and K
* Find ratio that concatnation random permutation of numbers are divisible by K

```txt
Input:
3
3
2
1
2

Output: 1/3
```

> Solution

* ab % x = {(a % x) * (len(10 ^ b) % x) + (b % x) } % x

{% endtab %}
{% tab title='BJ_1086.py' %}

```py
# Time: O(2^N K N)
import math
N = int(input())
nums = [int(input()) for _ in range(N)]
K = int(input())
G = [[(j * 10 ** len(str(nums[i])) + nums[i]) % K for j in range(K)] for i in range(N)]
dp = [[0] * K for _ in range(1<<N)]   # dp[i][j]: (Bit mask i) % k == j
dp[0][0] = 1
for b in range(1 << N):
  for i in range(N):
    if b & (1<<i): continue
    for j in range(K):
      dp[b | (1 << i)][G[i][j]] += dp[b][j]
p = dp[(1 << N) - 1][0]
q = sum(dp[(1 << N) - 1])
g = math.gcd(p, q)
print(f"{p // g}/{q//g}")
```

{% endtab %}
{% endtabs %}

* [Level 18 : 격자판 채우기](https://www.acmicpc.net/problem/1648)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-bit/BJ_1648.md/)

{% tabs %}
{% tab title='BJ_1648.md' %}

> Question

* How many ways can you fill n x m with 2 x 1 tile

```txt
Input: 3 6
Output: 41
```

> Solution

* Store which upper line is filled in binary

{% endtab %}
{% tab title='BJ_1648.py' %}

```py
n, m = map(int, input().split())
d=[[0] * (1 << m) for i in range(n * m + 1)]
d[n * m][0] = 1
for i in range(n * m - 1,- 1, -1):
  for j in range(1 << m):
    if j & 1:
      d[i][j] = d[i + 1][j >> 1]
      continue
    if i < (n - 1) * m:
      d[i][j] += d[i + 1][(1 << (m - 1)) | (j >> 1)]
    if i % m < m - 1 and not j % 4:
      d[i][j] += d[i + 2][j >> 2]
print(d[0][0] % 9901)
```

{% endtab %}
{% endtabs %}

* [Level 19 : 정수](https://www.acmicpc.net/problem/1040)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-bit/BJ_1040.md/)

{% tabs %}
{% tab title='BJ_1040.md' %}

> Question

* Print the smallest number with K different numbers greater or equal to N

```txt
Input: 47 1
Output: 55
```

{% endtab %}
{% tab title='BJ_1040.py' %}

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
bool br, v[15];

bool chk(ll p, ll q) {
  for (int i = 0; i <= 9; i++) v[i] = 0;
  for (; p > 0; p /= 10) v[p % 10] = 1;
  ll c = 0;
  for (int i = 0; i <= 9; i++) c += v[i];
  if (c <= k && c + q >= k) return 1;
  return 0;
}

int main() {
  ll n, k; cin >> n >> k;
  for (int i = 0; n > 0; i++) {
    for (int j = n % 10; j <= 9; j++, n++) {
      if (chk(n, i)) { br = 1; break; }
    }
    if (br) break;
    n /= 10;
  }
  for (int i--; i >= 0; i--) {
    n *= 10;
    for (int j = 0; j <= 9; j++, n++) {
      if (chk(n, i)) break;
    }
  }
  cout << n << endl;
  return 0;
}
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 3 : Smallest Sufficient Team](https://leetcode.com/problems/smallest-sufficient-team)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-bit/LC_1125.md/)

{% tabs %}
{% tab title='LC_1125.md' %}

> Question

* In a project, you have a list of required skills req_skills, and a list of people
* The ith person people[i] contains a list of skills that the person has
* Sufficient team: a set of people such that for every required skill in req_skills, there should be a person with that skill
  * We can represent these teams by the index of each person
* Return any sufficient team of the smallest possible size, represented by the index of each person in any order

```txt
Input: req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]
Output: [0,2]

Input:
req_skills = ["algorithms","math","java","reactjs","csharp","aws"],
people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],
  ["csharp","math"],["aws","java"]]
Output: [1,2]
```

{% endtab %}
{% tab title='LC_1125.py' %}

```py
def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:
  n, m = len(req_skills), len(people)
  key = {v: i for i, v in enumerate(req_skills)}
  dp = {0: []}
  for i, p in enumerate(people):
    his_skill = 0
    for skill in p:
      if skill in key:
        his_skill |= 1 << key[skill]
    for skill_set, need in list(dp.items()):
      with_him = skill_set | his_skill
      if with_him == skill_set: continue
      if with_him not in dp or len(dp[with_him]) > len(need) + 1:
        dp[with_him] = need + [i]
  return dp[(1 << n) - 1]
```

{% endtab %}
{% endtabs %}

* [Level 3 : Parallel Courses II](https://leetcode.com/problems/parallel-courses-ii)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/dynamic-programming/dp-bit/LC_1494.md/)

{% tabs %}
{% tab title='LC_1494.md' %}

> Question

* Given an integer n, which indicates that there are n courses labeled from 1 to n
* Given an array relations where relations[i] = [prev, next]
  * representing prerequisite relation between course prev and next: course prev has to be taken before course next
* Also, you are given the integer k.
* In one semester, take at most k courses if you have taken all prerequisites in previous semester for courses you are taking
* Return min number of semesters needed to take all courses, it is always possible to take every course.

```txt
Input: n = 4, dependencies = [[2,1],[3,1],[1,4]], k = 2
Output: 3

Input: n = 5, dependencies = [[2,1],[3,1],[4,1],[1,5]], k = 2
Output: 4
```

{% endtab %}
{% tab title='LC_1494.py' %}

```py
class Solution:
  def minNumberOfSemesters(self, n: int, dependencies: List[List[int]], k: int) -> int:
    post, pre = defaultdict(list), [0] * n
    for a, b in dependencies:
      pre[b-1] += 1
      post[a-1] += b-1,

    @lru_cache(None)
    def dfs(mask, pre):
      if not mask: return 0

      take = []
      for i in range(n):
        if mask & 1 << i and pre[i] == 0:
          take += i,

      res = inf
      for c in combinations(take, min(k, len(take))):
        m, d = mask, list(pre)
        for a in c:
          m ^= 1 << a
          for b in post[a]:
            d[b] -= 1
        res = min(res, 1 + dfs(m, tuple(d)))
      return res

    return dfs((1 << n) - 1, tuple(pre))
```

{% endtab %}
{% endtabs %}
