> baekjoon

* [Level 17 : ì§ì„  ì°¾ê¸°](https://www.acmicpc.net/problem/10523)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/randomization/BJ_10523.md/)

{% tabs %}
{% tab title='BJ_10523.md' %}

> Question

* check whether a line exists containing at least p percent of the points, i.e., dn Â· p/100e points

```txt
Input:
5
55
0 0
10 10
10 0
0 10
3 3

Output: possible
```

{% endtab %}
{% tab title='BJ_10523.py' %}

```py
import sys
import random
input = sys.stdin.readline
iter_n = 200

n, p = int(input()), int(input())
if n <= 2: print("possible")
else:
  point = [tuple(map(int, input().split())) for _ in range(n)]
  result = 0

  for _ in range(iter_n):
    m = 2
    a, b = random.sample(range(n), 2)
    x1, y1, x2, y2 = *point[a], *point[b]
    for i in range(n):
      if i == a or i == b: continue
      x, y = point[i]
      if (x - x1) * (y2 - y1) == (x2-x1)*(y-y1):
        m += 1
    if m * 100 >= p * n:
      result = 1
      break
  print(["im",""][result]+"possible")
```

{% endtab %}
{% endtabs %}

* [Level 18 : ë°±ì„¤ê³µì£¼ì™€ ë‚œìŸì´](https://www.acmicpc.net/problem/2912)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/randomization/BJ_2912.md/)

{% tabs %}
{% tab title='BJ_2912.md' %}

> Question

* Each dwarf has a colored cap, and there are C different colors
* A picture is pretty if more than half caps on it are of the same color
* if there are K dwarfs on the picture, it is pretty if more than K / 2 dwarfs have same colored caps

```txt
Input:
10 3
1 2 1 2 1 2 3 2 3 3
8
1 2
1 3
1 4
1 5
2 5
2 6
6 9
7 10

Output:
no
yes 1
no
yes 1
no
yes 2
no
yes 3
```

{% endtab %}
{% tab title='BJ_2912.py' %}

```py
# O(K C log N) : K is number of random
import random
from bisect import bisect_left, bisect_right

N, C = map(int, input().split())
dwarfs = [(0, 0) for _ in range(N+1)]
arr = [0] + list(map(int, input().split()))
for ind in range(1, N+1):
  color = arr[ind]
  dwarfs[ind] = (color, ind)
dwarfs.sort()

for _ in range(int(input())):
  s, e = map(int, input().split())
  for i in range(20):
    color = arr[random.randint(s, e)]
    if (e-s+1) / 2 < bisect_right(dwarfs, (color, e)) - bisect_left(dwarfs, (color, s)):
      print("yes", color)
      break
  else:
    print("no")
```

{% endtab %}
{% endtabs %}

* [Level 19 : ë™ì „ ë’¤ì§‘ê¸° 2](https://www.acmicpc.net/problem/2582)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/randomization/BJ_2582.md/)

{% tabs %}
{% tab title='BJ_2582.md' %}

> Question

* Print minimum number of up facing coins, given you can reverse row or column

```txt
Input:
3
HHT
THH
THT

Output: 2
```

{% endtab %}
{% tab title='BJ_2582.py' %}

```cpp
#include <bits/stdc++.h>
#define N 40
using namespace std;

int m = 100000, mn, a[N][N], b[N];
string t;

int fcnt() {
  int i, j, c, s = 0;
  for (int j = 0; j < n; j++) {
    c = 0;
    for (int i = 0; i < n; i++) {
      c += a[i][j] ^ b[i];
    }
    s += min(c, n - c);
  }
  return s;
}

int main() {
  int n; cin >> n;
  srand(time(0));
  for (int i = 0; i < n; i++) {
    cin >> t;
    for (int j = 0; j < n; j++)
      a[i][j] = (t[j] == 'T');
  }
  mn = fcnt();
  while (m--) {
    int rd = rand() % n;
    int t1 = fcnt();
    b[rd] ^= 1;
    int t2 = fcnt();
    if (t2 > t1 && rand() % 50) b[rd] ^= 1;
    mn = min(mn, t2);
  }
  cout << mn << endl;
  return 0;
}
```

{% endtab %}
{% endtabs %}

> codeforces

* [Level 2000 : Cut and Stick](https://codeforces.com/contest/1514/problem/D)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/randomization/CF_1514D.md/)

{% tabs %}
{% tab title='CF_1514d.md' %}

> Question

* print minimum number of cut into partitions the sequence ğ‘ğ‘™, ğ‘ğ‘™+1, ..., ğ‘ğ‘Ÿ into subsequences
* so that, if it has length ğ‘¥, then no value occurs strictly more than âŒˆğ‘¥/2âŒ‰ times in it

```txt
Input:
6 2
1 3 2 3 3 2
1 6
2 5
Output:
1   # 1 3 2 3 3 2
2   # 3 / 2 3 3
```

> Solution

* pick ~40 random elements from range to be candidates for super-frequent element, then count their occurrences and maximize
* If there's a super-frequent element, the probability it's not picked is at most 2^âˆ’40
* upper_bound(r)-lower_bound(l) gives us the number of occurrences in ğ‘‚(ğ‘™ğ‘œğ‘”(ğ‘›))

{% endtab %}
{% tab title='CF_1514d.py' %}

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[300005];
vector<int> v[300005];

int main() {
  int n, q;
  cin >> n >> q;
  for (int i = 1;i <= n; i++) {
    scanf("%d", &a[i]);
    v[a[i]].push_back(i);
  }
  mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
  while (q--) {
    int l, r, ans = 1; cin >> l >> r;
    for (int _ = 0; _ < 40; _++) {
      int c = a[uniform_int_distribution<int>(l, r)(rng)];
      int f = upper_bound(v[c].begin(), v[c].end(), r) - lower_bound(v[c].begin(),v[c].end(), l);
      ans = max(ans, 2 * f - (r - l + 1));
    }
    cout << ans << endl;
  }
}
```

{% endtab %}
{% endtabs %}

* [Level 2400 : Love-Hate](https://codeforces.com/contest/1523/problem/D)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/randomization/CF_1523D.md/)

{% tabs %}
{% tab title='CF_1523D.md' %}

> Question

* There are ğ‘– persoen, it is known whether he likes currency ğ‘—
* There are ğ‘š currencies in total, person like at most ğ‘ currencies
* Print a string of length ğ‘š, which defines subset of currencies of maximum size, liked by at least half of all friends

```txt
Input:
3 4 3
1000
0110
1001

Output:
1000
```

{% endtab %}
{% tab title='CF_1523D.py' %}

```py
import sys; input = sys.stdin.readline
from random import shuffle
n, m, p = map(int, input().split())
A, order = [input()[:-1] for _ in range(n)], list(range(n))
shuffle(order)
best, sub = 0, '0' * m
for it in range(min(n, 10)):
  x = order[it]
  bits = [j for j in range(m) if A[x][j] == '1']
  sz, cnt = len(bits), [0] * (1 << sz)
  for i in range(n):
    cur = sum(1 << j for j in range(sz) if A[i][bits[j]] == '1')
    cnt[cur] += 1
  for i in range(sz):
    for mask in range(1 << sz):
      if mask & (1 << i):
        cnt[mask ^ (1 << i)] += cnt[mask]
  for mask in range(1 << sz):
    if 2 * cnt[mask] >= n and bin(mask).count('1') > best:
      best, sub = bin(mask).count('1'), ['0'] * m
      for i in range(sz):
        if mask >> i & 1: sub[bits[i]] = '1'
      sub = "".join(sub)
print(sub)
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 3 : Online Majority Element In Subarray](https://leetcode.com/problems/online-majority-element-in-subarray)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/randomization/LC_1157.md/)

{% tabs %}
{% tab title='LC_1157.md' %}

> Question

* MajorityChecker(int[] arr) constructs an instance of MajorityChecker with the given array arr;
* int query(int left, int right, int threshold) has arguments such that:
  * 0 <= left <= right < arr.length representing a subarray of arr;
  * 2 * threshold > right - left + 1, ie. the threshold is always a strict majority of the length of the subarray

```txt
MajorityChecker majorityChecker = new MajorityChecker([1,1,2,2,1,1]);
majorityChecker.query(0,5,4); // returns 1
majorityChecker.query(0,3,3); // returns -1
majorityChecker.query(2,3,2); // returns 2
```

{% endtab %}
{% tab title='LC_1157.py' %}

```py
from bisect import bisect_left, bisect_right
class MajorityChecker(object):
  def __init__(self, A):
    a2i = collections.defaultdict(list)
    for i, x in enumerate(A):
      a2i[x].append(i)
    self.A, self.a2i = A, a2i

  def query(self, left, right, threshold):
    for _ in range(20):
      a = self.A[random.randint(left, right)]
      if bisect_right(self.a2i[a], right) - bisect_left(self.a2i[a], left) >= threshold:
        return a
    return -1
```

{% endtab %}
{% endtabs %}
