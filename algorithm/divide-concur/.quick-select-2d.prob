> leetcode

* [Level 2 : Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/divide-concur/quick-select-2d/LC_373.md/)

{% tabs %}
{% tab title='LC_373.md' %}

> Question

* Given two integer arrays nums1 and nums2 sorted in ascending order and an integer k
* Define a pair (u, v) which consists of one element from first array and one element from second array
* Return k pairs (u1, v1), (u2, v2), ..., (uk, vk) with smallest sums

```txt
Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]

Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
Output: [[1,1],[1,1]]
```

{% endtab %}
{% tab title='LC_373.py' %}

```py
def kSmallestPairs(self, nums1, nums2, k):
  streams = map(lambda u: ([u + v, u, v] for v in nums2), nums1)
  stream = heapq.merge(*streams)
  return [suv[1:] for suv in islice(stream, k)]
```

{% endtab %}
{% endtabs %}

* [Level 2 : Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/divide-concur/quick-select-2d/LC_378.md/)

{% tabs %}
{% tab title='LC_378.md' %}

> Question

* Given an n x n matrix where each of rows and columns are sorted in ascending order, return kth smallest element in matrix
* Note that it is kth smallest element in sorted order, not kth distinct element

```txt
Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
```

{% endtab %}
{% tab title='LC_378.cpp' %}

```cpp
// Time: O(n * log(n) * log(N))
// Space: O(1)
int kthSmallest(vector<vector<int>>& matrix, int k) {
  int n = matrix.size();
  int lo = matrix[0][0], hi = matrix[n-1][n-1];
  while (lo < hi) {
    int mi = (lo + hi) / 2;
    int count = 0;  // number of elements no bigger than mi
    for (int i = 0; i < n; i++) {
      vector<int>& row = matrix[i];
      count += std::upper_bound(row.begin(), row.end(), mi) - row.begin();
    }
    if (count < k)
      lo = mi + 1;
    else
      hi = mi;
  }
  return lo;
}
```

{% endtab %}
{% tab title='LC_378.py' %}

```py
# Time: O(n * log n)
# Space: O(1)
def kthSmallest(self, matrix, k):
  return sorted(itertools.chain(*matrix))[k - 1]
```

{% endtab %}
{% endtabs %}

* [Level 3 : Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/divide-concur/quick-select-2d/LC_668.md/)

{% tabs %}
{% tab title='LC_668.md' %}

> Question

* Multiplication table of size m x n is integer matrix mat where mat[i][j] == i * j (1-indexed)
* Given three integers m, n, and k, return kth smallest element in the m x n multiplication table

```txt
Input: m = 3, n = 3, k = 5
Output: 3  # 1, 2, 2, 3, 3
```

{% endtab %}
{% tab title='LC_668.py' %}

```py
def findKthNumber(self, m, n, k):
  def enough(x):
    return sum(min(x // i, n) for i in range(1, m + 1)) >= k

  lo, hi = 1, m * n
  while lo < hi:
    mi = (lo + hi) // 2
    if not enough(mi):
      lo = mi + 1
    else:
      hi = mi
  return lo
```

{% endtab %}
{% endtabs %}

* [Level 3 : Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/divide-concur/quick-select-2d/LC_719.md/)

{% tabs %}
{% tab title='LC_719.md' %}

> Question

* Distance of a pair of integers a and b is defined as absolute difference between a and b.
* Given an integer array nums and an integer k, return kth smallest distance among all the pairs nums[i] and nums[j]
  * where 0 <= i < j < nums.length.

```txt
Input: nums = [1,3,1], k = 1
Output: 0

Input: nums = [1,1,1], k = 2
Output: 0
```

{% endtab %}
{% tab title='LC_719.py' %}

```py
def smallestDistancePair(self, li: List[int], k: int) -> int:
  def enough(distance) -> bool:  # two pointers
    count, l, r = 0, 0, 0
    while l < len(li) or r < len(li):
      while r < len(li) and li[r] - li[l] <= distance:
        r += 1
      count += r - l - 1
      l += 1
    return count >= k

  li.sort()
  l, r = 0, li[-1] - li[0]
  while l < r:
    m = l + (r - l) // 2
    if not enough(m):
      l = m + 1
    else:
      r = m
  return l
```

{% endtab %}
{% endtabs %}

* [Level 3 : K-th Smallest Prime Fraction](https://leetcode.com/problems/k-th-smallest-prime-fraction)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/divide-concur/quick-select-2d/LC_786.md/)

```py
def kthSmallestPrimeFraction(self, A, K):
  def kthSmallest(matrix, k):
    # Can be improved from LC_378
    return sorted(itertools.chain(*matrix))[k - 1]
  class Row(int):
    def __getitem__(self, j):
      return float(self) / A[~j], [int(self), A[~j]]
  return kthSmallest(map(Row, A), K)[1]
```
