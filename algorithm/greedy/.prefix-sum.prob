> baekjoon

* [Level 8 : 구간 합 구하기 4](https://www.acmicpc.net/problem/11659)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/prefix-sum/BJ_11659.md/)

{% tabs %}
{% tab title='BJ_11659.md' %}

> Question

* For each line print sum between a, b

```txt
Input:
5 3
5 4 3 2 1
1 3
2 4
5 5

Output:
12
9
1
```

{% endtab %}
{% tab title='BJ_11659.py' %}

```py
from itertools import accumulate
import sys

input()
s = list(accumulate(map(int, input().split()), initial=0))
for line in sys.stdin:
  a, b = map(int, line.split())
  print(s[b] - s[a - 1])
```

{% endtab %}
{% endtabs %}

* [Level 8 : 수들의 합 2](https://www.acmicpc.net/problem/2003)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/prefix-sum/BJ_2003.md/)

{% tabs %}
{% tab title='BJ_2003.md' %}

> Question

* Find number of ways where A[i] + A[i+1] + … + A[j-1] + A[j] == M

```txt
Input:
10 5
1 2 3 4 2 5 3 1 1 2

Output: 3
```

{% endtab %}
{% tab title='BJ_2003.py' %}

```py
N, M = map(int, input().split())
nums = list(map(int, input().split()))
accums = [0] * (N + 1)
for i in range(1, N + 1):
  accums[i] = accums[i - 1] + nums[i - 1]
count = 0
for l in range(N):
  for r in range(l + 1, N + 1):
    if accums[r] - accums[l] > M:
      break
    elif accums[r] - accums[l] == M:
      count += 1
      break
print(count)
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 1 : Range Sum Query - Immutable](https://leetcode.com/problems/range-sum-query-immutable)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/prefix-sum/LC_303.md/)

{% tabs %}
{% tab title='LC_303.md' %}

> Question

* Implement the NumArray class:
* NumArray(int[] nums) Initializes the object with the integer array nums.
* int sumRange(int left, int right) Returns sum of elements of nums between indices left and right inclusive
  * ([ex] nums[left] + nums[left + 1] + ... + nums[right]).

```txt
Input:
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]

Output: [null, 1, -1, -3]
```

{% endtab %}
{% tab title='LC_303.py' %}

```py
class NumArray:
  def __init__(self, nums: List[int]):
    summ = 0
    self.prefix = [summ := summ + num for num in nums]

  def sumRange(self, i: int, j: int) -> int:
    return self.prefix[j] - (self.prefix[i - 1] if i > 0 else 0)
```

{% endtab %}
{% endtabs %}

* [Level 2 : Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/prefix-sum/LC_523.md/)

{% tabs %}
{% tab title='LC_523.md' %}

> Question

* Given an integer array nums and an integer k
* return if nums has a continuous subarray of size at least two whose elements sum up to a multiple of k

```txt
Input: nums = [23,2,4,6,7], k = 6
Output: true
```

{% endtab %}
{% tab title='LC_523.py' %}

```py
# Time, Space : O(N), O(N)
def checkSubarraySum(self, A, k):
  seen, cur = {0: -1}, 0
  for i, a in enumerate(A):
    cur = (cur + a) % abs(k) if k else cur + a
    if i - seen.setdefault(cur, i) > 1:
      return True
  return False
```

{% endtab %}
{% endtabs %}

* [Level 2 : Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/prefix-sum/LC_560.md/)

{% tabs %}
{% tab title='LC_560.md' %}

> Question

* Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k

```txt
Input: nums = [1,1,1], k = 2
Output: 2
```

{% endtab %}
{% tab title='LC_560.py' %}

```py
def subarraySum(self, nums: List[int], k: int) -> int:
  count, cur, res = {0: 1}, 0, 0
  for v in nums:
    cur += v
    res += count.get(cur - k, 0)
    count[cur] = count.get(cur, 0) + 1
  return res
```

{% endtab %}
{% endtabs %}

* [Level 3 : Sum of Floored Pairs](https://leetcode.com/problems/sum-of-floored-pairs)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/prefix-sum/LC_1862.md/)

{% tabs %}
{% tab title='LC_1862.md' %}

> Question

* Given integer array, return sum of floor(nums[i] / nums[j]) for all pairs 0 <= i, j < nums.length MOD 10^9+7
* The floor() function returns the integer part of the division.

```txt
Input: nums = [2,5,9]
Output: 10

Input: nums = [7,7,7,7,7,7,7]
Output: 49
```

{% endtab %}
{% tab title='LC_1862.py' %}

```py
def sumOfFlooredPairs(self, nums: List[int]) -> int:
  incs, co = [0] * (max(nums) + 1), Counter(nums)  # To store all the quotients increases
  for num in co:
    for j in range(num, len(incs), num):  # Loop over all the possible dividends where the quotient increases
      incs[j] += co[num]  # Increment the increases in quotients
  quots = list(accumulate(incs))  # Accumulate the increases to get the sum of quotients
  return sum([quots[num] for num in nums]) % 1_000_000_007  # Sum up all the quotients for all the numbers in the list
```

{% endtab %}
{% endtabs %}
