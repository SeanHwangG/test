> leetcode

* [Level 1 : Valid Palindrome](https://leetcode.com/problems/valid-palindrome)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_125.md/)

{% tabs %}
{% tab title='LC_125.md' %}

> Question

* Check if string is palindrome

```txt
Input: s = "A man, a plan, a canal: Panama"
Output: true
```

{% endtab %}
{% tab title='LC_125.py' %}

```cpp
bool isPalindrome(string s) {
  int i = 0, j = s.size() - 1;
  while (i < j){
    while (!isalpha(s[i]) && !isdigit(s[i]))  i++;
    while (!isalpha(s[j]) && !isdigit(s[j]))  j--;
    if (i < j && tolower(s[i++]) != tolower(s[j--])) return false;
  }
  return true;
}
```

{% endtab %}
{% endtabs %}

* [Level 1 : Two Sum II - Input array is sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_167.md/)

{% tabs %}
{% tab title='LC_167.md' %}

> Question

* find two indices that sum up to target in sorted array

```txt
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
```

{% endtab %}
{% tab title='LC_167.py' %}

```py
def twoSum1(self, numbers, target):
  l, r = 0, len(numbers) - 1
  while l < r:
    s = numbers[l] + numbers[r]
    if s == target:
      return [l + 1, r + 1]
    elif s < target:
      l += 1
    else:
      r -= 1
```

{% endtab %}
{% endtabs %}

* [Level 2 : Container With Most Water](https://leetcode.com/problems/container-with-most-water)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_11.md/)

{% tabs %}
{% tab title='LC_11.md' %}

> Question

* Find two lines, which, together with the x-axis forms a container, such that the container contains the most water

![LC_11.md](two-pointer/images/20210411_061316.png)

```txt
Input: height = [4,3,2,1,4]
Output: 16
```

{% endtab %}
{% tab title='LC_11.py' %}

```py
def maxArea(self, height):
  i, j = 0, len(height) - 1
  water = 0
  while i < j:
    water = max(water, (j - i) * min(height[i], height[j]))
    if height[i] < height[j]:
      i += 1
    else:
      j -= 1
  return water
```

{% endtab %}
{% endtabs %}

* [Level 2 : 3Sum](https://leetcode.com/problems/3sum)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_15.md/)

{% tabs %}
{% tab title='LC_15.md' %}

> Question

* find list of three indices that sums up to zero

```txt
Input: nums = [-1,2,1,-4], target = 1
Output: 2
```

{% endtab %}
{% tab title='LC_15.py' %}

```py
def threeSum(self, nums):
  res = []
  nums.sort()
  for i in range(len(nums) - 2):
    if i > 0 and nums[i] == nums[i-1]: continue
    l, r = i + 1, len(nums) - 1
    while l < r :
      s = nums[i] + nums[l] + nums[r]
      if s == 0:
        res.append([nums[i] ,nums[l] ,nums[r]])
        l += 1; r -= 1
        while l < r and nums[l] == nums[l - 1]: l += 1
        while l < r and nums[r] == nums[r + 1]: r -= 1
      elif s < 0:
        l += 1
      else:
        r -= 1
  return res
```

{% endtab %}
{% endtabs %}

* [Level 2 : 3Sum Closest](https://leetcode.com/problems/3sum-closest)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_16.md/)

{% tabs %}
{% tab title='LC_16.md' %}

> Question

* Given an array S of n integers, find three integers in S such that the sum is closest to a given number, target

```txt
Input: nums = [-1,2,1,-4], target = 1
Output: 2
```

{% endtab %}
{% tab title='LC_16.java' %}

```java
public int threeSumClosest(int[] nums, int target) {
  if (nums == null || nums.length < 3) return 0;
  Arrays.sort(nums);
  int sum = 0, closest = nums[0] + nums[1] + nums[2];
  for (int i = 0; i < nums.length - 2; i++) {
    if (i > 1 && nums[i] == nums[i - 1]) continue;
    int lo = i + 1, hi = nums.length - 1;
    while (lo < hi) {
      sum = nums[i] + nums[lo] + nums[hi];
      if (sum == target) return target;
      else if (sum < target) lo++;
      else hi--;
      if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum;
    }
  }
  return closest;
}
```

{% endtab %}
{% endtabs %}

* [Level 2 : 4Sum](https://leetcode.com/problems/4sum)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_18.md/)

{% tabs %}
{% tab title='LC_18.md' %}

> Question

* Given an array nums of n integers and an target, find unique set of a, b, c, and d that sums up to target

```txt
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

{% endtab %}
{% tab title='LC_18.py' %}

```py
def fourSum(self, nums, target):
  def findNsum(nums, target, N, cur, results):
    if len(nums) == 0 or not (nums[0] * N <= target <= nums[-1] * N):
      return
    if N == 2:
      l, r = 0, len(nums) - 1
      while l < r:
        s = nums[l] + nums[r]
        if s == target:
          results.append(cur + [nums[l], nums[r]])
          l += 1
          while l < r and nums[l] == nums[l-1]:
            l += 1
        elif s < target:    l += 1
        else:               r -= 1
    else:
      for i in range(len(nums) - N + 1):
        if i == 0 or nums[i - 1] != nums[i]:
          findNsum(nums[i + 1:], target - nums[i], N - 1, cur + [nums[i]], results)

  results = []
  findNsum(sorted(nums), target, 4, [], results)
  return results
```

{% endtab %}
{% endtabs %}

* [Level 2 : Maximum Distance Between a Pair of Values](https://leetcode.com/problems/maximum-distance-between-a-pair-of-values)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_1855.md/)

{% tabs %}
{% tab title='LC_1855.md' %}

> Question

* given two non-increasing 0-indexed integer arrays nums1​​​​​​ and nums2​​​​​​
* A pair of indices (i, j), where 0 <= i < nums1.length and 0 <= j < nums2.length, is valid if i <= j and nums1[i] <= nums2[j]
* Return the maximum (j - i) of any valid pair (i, j). If there are no valid pairs, return 0

```txt
Input: nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]
Output: 2
```

{% endtab %}
{% tab title='LC_1855.cpp' %}

```cpp
int maxDistance(vector<int>& A, vector<int>& B) {
  int i = 0, j = 0, res = 0, n = A.size(), m = B.size();
  while (i < n && j < m) {
    if (A[i] > B[j])
      i++;
    else
      res = max(res, j++ - i);
  }
  return res;
}
```

{% endtab %}
{% endtabs %}

* [Level 2 : 3Sum Smaller](https://leetcode.com/problems/3sum-smaller)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_259.md/)

{% tabs %}
{% tab title='LC_259.md' %}

> Question

* Given an integers and a target
* find number of index triplets i, j, k with 0 <= i < j < k < n st condition nums[i] + nums[j] + nums[k] < target

```txt
Input: nums = [-2,0,1,3], and target = 2
Output: 2
```

{% endtab %}
{% tab title='LC_259.py' %}

```py
def threeSumSmaller(self, nums, target):
  count = 0
  nums.sort()
  for i in range(len(nums)):
    j, k = i + 1, len(nums)-1
    while j < k:
      s = nums[i] + nums[j] + nums[k]
      if s < target:
        count += k-j # if (i,j,k) works, then (i,j,k), (i,j,k-1) ... (i, j, j + 1)
        j += 1
      else:
        k -= 1
  return count
```

{% endtab %}
{% endtabs %}

* [Level 2 : Wiggle Sort II](https://leetcode.com/problems/wiggle-sort-ii)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_324.md/)

{% tabs %}
{% tab title='LC_324.md' %}

> Question

* Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]...
* You may assume the input array always has a valid answer

```txt
Input: nums = [1,5,1,1,6,4]
Output: [1,6,1,5,1,4]
```

{% endtab %}
{% tab title='LC_324.cpp' %}

```cpp
void wiggleSort(vector<int>& nums) {
  int n = nums.size();

  auto midptr = nums.begin() + n / 2;
  nth_element(nums.begin(), midptr, nums.end());
  int mid = *midptr;
  #define A(i) nums[(1+2*(i)) % (n|1)]

  // 3-way-partition-to-wiggly in O(n) time with O(1) space.
  int i = 0, j = 0, k = n - 1;
  while (j <= k) {
    if (A(j) > mid)
      swap(A(i++), A(j++));
    else if (A(j) < mid)
      swap(A(j), A(k--));
    else
      j++;
  }
}
```

{% endtab %}
{% endtabs %}

* [Level 2 : K-diff Pairs in an Array](https://leetcode.com/problems/k-diff-pairs-in-an-array)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_532.md/)

{% tabs %}
{% tab title='LC_532.md' %}

> Question

* Given Array, find number of pairs with difference k

```txt
Input: nums = [3,1,4,1,5], k = 2
Output: 2
```

{% endtab %}
{% tab title='LC_532.java' %}

```java
public int findPairs(int[] nums, int k) {
  Map<Integer, Integer> cnt = new HashMap<>();
  for (int x : nums)
    cnt.put(x, cnt.getOrDefault(x, 0) + 1);
  int res = 0;
  for (int x : cnt.keySet()) {
    if ((k > 0 && cnt.containsKey(x + k)) || (k == 0 && cnt.get(x) > 1))
      res++;
  }
  return res;
}
```

{% endtab %}
{% tab title='LC_532.py' %}

```py
def findPairs(self, nums, k):
  c = collections.Counter(nums)
  return  sum(k > 0 and i + k in c or k == 0 and c[i] > 1 for i in c)
```

{% endtab %}
{% endtabs %}

* [Level 2 : Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_647.md/)

{% tabs %}
{% tab title='LC_647.md' %}

> Question

* Given a string s, return the number of palindromic substrings in it
* A substring is a contiguous sequence of characters within the string

```txt
Input: s = "aaa"
Output: 6
```

{% endtab %}
{% tab title='LC_647.cpp' %}

```cpp
int countSubstrings(string s) {
  int res = 0, n = s.length();
  for(int i = 0; i < n; i++){
    //substring s[i-j, ..., i+j]
    for(int j = 0; i-j >= 0 && i+j < n && s[i-j] == s[i+j]; j++) res++;
    //substring s[i-1-j, ..., i+j]
    for(int j = 0; i-1-j >= 0 && i+j < n && s[i-1-j] == s[i+j]; j++) res++;
  }
  return res;
}
```

{% endtab %}
{% tab title='LC_647.py' %}

```py
def countSubstrings(self, S):
  def manachers(S): # represents the maximum half-length of a palindrome at some center
    A = '@#' + '#'.join(S) + '#$'
    Z = [0] * len(A)
    center = right = 0
    for i in range(1, len(A) - 1):
      if i < right:
        Z[i] = min(right - i, Z[2 * center - i])
      while A[i + Z[i] + 1] == A[i - Z[i] - 1]:
        Z[i] += 1
      if i + Z[i] > right:
        center, right = i, i + Z[i]
    return Z
  return sum((v + 1) // 2 for v in manachers(S))
```

{% endtab %}
{% endtabs %}

* [Level 2 : Sort Colors](https://leetcode.com/problems/sort-colors)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_75.md/)

{% tabs %}
{% tab title='LC_75.md' %}

> Question

* Sort three number

```txt
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
```

{% endtab %}
{% tab title='LC_75.py' %}

```py
def sortColors(self, nums):
  red, white, blue = 0, 0, len(nums)-1

  while white <= blue:
    if nums[white] == 0:
      nums[red], nums[white] = nums[white], nums[red]
      white += 1
      red += 1
    elif nums[white] == 1:
      white += 1
    else:
      nums[white], nums[blue] = nums[blue], nums[white]
      blue -= 1
```

{% endtab %}
{% endtabs %}

* [Level 2 : Partition Labels](https://leetcode.com/problems/partition-labels)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_763.md/)

{% tabs %}
{% tab title='LC_763.md' %}

> Question

* A string s of lowercase English letters is given
* Partition this string into as many parts as possible so that each letter appears in at most one part
* return a list of size of these parts

```txt
Input: s = "ababcbacadefegdehijhklij"
Output: [9,7,8]
```

{% endtab %}
{% tab title='LC_763.py' %}

```py
def partitionLabels(self, s: str) -> List[int]:
  rightmost = {c : i for i, c in enumerate(s)}
  l, r = 0, 0
  result = []
  for i, letter in enumerate(s):
    r = max(r, rightmost[letter])
    if i == r:
      result += [r-l + 1]
      l = i + 1
  return result
```

{% endtab %}
{% endtabs %}

* [Level 3 : Count Pairs Of Nodes](https://leetcode.com/problems/count-pairs-of-nodes)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_1782.md/)

{% tabs %}
{% tab title='LC_1782.md' %}

> Question

* An undirected graph with n number of nodes, and an integer array queries are given
* The answer to the jth query is the number of pairs of nodes (a, b) that satisfy the following conditions:
  * a < b
  * cnt is strictly greater than queries[j], where cnt is the number of edges incident to a or b
* Return an array answers where answers[j] is the answer of the jth query

```txt
Input: n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3]
Output: [6,5]
```

{% endtab %}
{% tab title='LC_1782.py' %}

```py
def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:
  v2count, res = Counter(v for edge in edges for v in edge), [0] * len(queries)
  shared = Counter((min(n1, n2), max(n1, n2)) for n1, n2 in edges)
  sorted_cnt = sorted(list(v2count.values()) + [0] * (n + 1 - len(v2count)))
  for k, q in enumerate(queries):
    i, j = 1, n
    while i < j:
      if q < sorted_cnt[i] + sorted_cnt[j]:   # for each j add all ignoring intersection
        res[k] += j - i
        j -= 1
      else:
        i += 1
    for (i, j), sh_cnt in shared.items():
      if q < v2count[i] + v2count[j] <= q + sh_cnt:
        res[k] -= 1
  return res
```

{% endtab %}
{% endtabs %}

* [Level 3 : Maximum Score of a Good Subarray](https://leetcode.com/problems/maximum-score-of-a-good-subarray)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_1793.md/)

{% tabs %}
{% tab title='LC_1793.md' %}

> Question

* Given an array of integers nums (0-indexed) and an integer k
* score of a subarray (i, j) is min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). good subarray if i <= k <= j
* Return the maximum possible score of a good subarray

```txt
Input: nums = [1,4,3,7,4,5], k = 3
Output: 15
```

{% endtab %}
{% tab title='LC_1793.py' %}

```py
def maximumScore(self, nums: List[int], k: int) -> int:
  res = mini = nums[k]
  i, j, n = k, k, len(nums)
  while i > 0 or j < n - 1:
    if (nums[i - 1] if i else 0) < (nums[j + 1] if j < n - 1 else 0):
      j += 1
    else:
      i -= 1
    mini = min(mini, nums[i], nums[j])
    res = max(res, mini * (j - i + 1))
  return res
```

{% endtab %}
{% endtabs %}

* [Level 3 : Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_42.md/)

{% tabs %}
{% tab title='LC_42.md' %}

> Question

* Given n non-negative integers representing an elevation map where the width of each bar is 1
* compute how much water it can trap after raining

```txt
Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
```

{% endtab %}
{% tab title='LC_42.cpp' %}

```cpp
int trap(vector<int>& height) {
  int l = 0, r = height.size() - 1, level = 0, water = 0;
  while (l < r) {
    int lower = height[height[l] < height[r] ? l++ : r--];
    level = max(level, lower);
    water += level - lower;
  }
  return water;
}
```

{% endtab %}
{% endtabs %}

* [Level 3 : Wildcard Matching](https://leetcode.com/problems/wildcard-matching)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/algorithm/greedy/two-pointer/LC_44.md/)

{% tabs %}
{% tab title='LC_44.md' %}

> Question

* Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:

```txt
Input: s = "adceb", p = "*a*?"
Output: true
```

{% endtab %}
{% tab title='LC_44.cpp' %}

```cpp
// Time O(N + M) / Space O(1)
class Solution {
public:
   bool isMatch(string s, string p) {
    int i = 0, j = 0;
    int m = s.length(), n = p.length();
    int last_match = -1, starj = -1;
    while (i < m){
      if (j < n && (s[i] == p[j] || p[j] == '?')){
        i++; j++;
      }
      else if (j < n && p[j] == '*'){
        starj = j;
        j++;
        last_match = i;
      }
      else if (starj != -1){
        j = starj + 1;
        last_match++;
        i = last_match;
      }
      else return false;
    }
    while (p[j] == '*' && j <n) j++;
    return j == n;
  }
};
```

{% endtab %}
{% tab title='LC_44.py' %}

```py
# Time / Space : O(m * n)
def isMatch(self, s, p):
  length = len(s)
  if len(p) - p.count('*') > length:
    return False
  dp = [True] + [False]*length
  for i in p:
    if i != '*':
      for n in reversed(range(length)):
        dp[n+1] = dp[n] and (i == s[n] or i == '?')
    else:
      for n in range(1, length+1):
        dp[n] = dp[n-1] or dp[n]
    dp[0] = dp[0] and i == '*'
  return dp[-1]
```

{% endtab %}
{% endtabs %}
