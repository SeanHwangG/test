> baekjoon

* [Level 19 : 나무 자르기](https://www.acmicpc.net/problem/13263)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/geometry/convex-haul-dp/BJ_13263.md/)

{% tabs %}
{% tab title='BJ_13263.md' %}

> Question

* Given two lists, L (height of the tree at i) and B (cost of charge at i)
  * A1 = 1, Bn = 0, A1 < A2 < ... < An, B1 > B2 > ... > Bn
* Find minimum sum of cost to cut all tree if it costs min(B with height=0) to reduce height by 1

```txt
Input:
5
1 2 3 4 5
5 4 3 2 0

Output: 25
```

> Solution

* dp[i] = min(dp[j] + B[j] * A[i])

{% endtab %}
{% tab title='BJ_13263.py' %}

```py
def cross(x, y):
  ax, bx, ay, by = *hull[x], *hull[y]
  return (by - bx) / (ax - ay)

def insert(A, B):
  hull.append((A, B))
  while len(hull) > 2 and cross(-2, -3) > cross(-1, -2):
    hull.pop(-2)

n = int(input())
A = list(map(int,input().split()))
B = list(map(int,input().split()))
p = 0
dp = [0]
hull = [(B[0], 0)]
for i in range(1, n):
  while p + 1 < len(hull) and cross(p, p + 1) <= A[i]:
    p += 1
  dp.append(hull[p][0] * A[i] + hull[p][1])
  insert(B[i], dp[i])
print(dp[-1])
```

{% endtab %}
{% endtabs %}

* [Level 20 : 특공대](https://www.acmicpc.net/problem/4008)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/geometry/convex-haul-dp/BJ_4008.md/)

{% tabs %}
{% tab title='BJ_4008.md' %}

> Question

* Given a, b,c and list X
* Divide X into subarray and define f(x) when x is sum of that subarray
  * f(x) = a x ** 2 + b x + c
* Print maximum sum of f(x)

```txt
Input:
4
-1 10 -20
2 2 3 4

Output: 9
```

> Solution

$$ DP[i] = min_{j<i} ( DP[j] + a(pre[i] − pre[j])^2 + b(pre[i] − pre[j]) + c) $$

{% endtab %}
{% tab title='BJ_4008.cpp' %}

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
int sz, pt;
ll S[1000100], P[1000100];

#define cross(a,b,c,d) (double)(b-d)/(c-a)

void add(ll a, ll b){
  while (sz > 1 && cross(S[sz-2], P[sz-2], a, b) < cross(S[sz-2], P[sz-2], S[sz-1], P[sz-1]))
    sz--;
  S[sz] = a;
  P[sz] = b;
  sz++;
}

ll query(ll p){
  pt = min(pt, sz - 1);
  while (pt + 1 < sz && cross( S[pt], P[pt], S[pt + 1], P[pt + 1] ) < p)
    pt++;
  return S[pt] * p + P[pt];
}

int N;
ll A, B, C, a, d, p;
int main(){
  cin >> N >> A >> B >> C;
  add(0, 0);
  for (int i = 1; i <= N; i++) {
    cin >> a;
    p += a;
    d = query(p) + A * p * p + B * p + C;
    add(-2 * A * p, d + A * p * p - B * p);
  }
  cout << d;
  return 0;
}
```

{% endtab %}
{% endtabs %}
