> baekjoon

* [Level 17 : 로버트 후드](https://www.acmicpc.net/problem/9240)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/geometry/rotating-calipers/BJ_9240.md/)

{% tabs %}
{% tab title='BJ_9240.md' %}

> Question

* Print two points with maximum distance

```txt
Input:
5
-4 1
-100 0
0 4
2 -3
2 300

Output:
316.86590223
```

{% endtab %}
{% tab title='BJ_9240.py' %}

```py
from sys import stdin
input = lambda: stdin.readline().strip()

def ccw(p1, p2, p3):
  return (p2[0]-p1[0])*(p3[1]-p1[1]) - (p2[1]-p1[1])*(p3[0]-p1[0])

def convex_haul(p):
  U = []; L = []; p.sort()
  for q in p:
    while len(U) > 1 and ccw(U[-2], U[-1], q) >= 0:
      U.pop()
    while len(L) > 1 and ccw(L[-2], L[-1], q) <= 0:
      L.pop()
    U.append(q); L.append(q)
  return U, L

def rot_cal(p):
  U, L = convex_haul(p)
  i = 0; j = len(L)-1
  i = 0; j = len(L)-1
  while i < len(U)-1 or j > 0:
    yield U[i],L[j]
    if i == len(U)-1:
      j -= 1
    elif j == 0:
      i += 1
    elif (U[i+1][1]-U[i][1]) * (L[j][0]-L[j-1][0]) > (L[j][1]-L[j-1][1])*(U[i+1][0]-U[i][0]):
      i += 1
    else: j-= 1

def distsq(ptup):
  p1, p2 = ptup
  x1, y1 = p1; x2, y2 = p2
  return (x2-x1)**2 + (y2-y1)**2

n = int(input())
p = [tuple(map(int, input().split())) for i in range(n)]
print(distsq(max(rot_cal(p), key = distsq)) ** 0.5)
```

{% endtab %}
{% endtabs %}

* [Level 19 : 고속도로](https://www.acmicpc.net/problem/10254)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/geometry/rotating-calipers/BJ_10254.md/)

{% tabs %}
{% tab title='BJ_10254.md' %}

> Question

* Print two points with maximum distance

```txt
Input:
2
4
-100 -50
20 -50
-20 50
100 50
9
-1 -1
3 -3
6 -6
-3 -6
12 0
3 4
-6 3
0 9
6 9

Output:
-100 -50 100 50
-6 3 12 0
```

{% endtab %}
{% tab title='BJ_10254.py' %}

```py
from sys import stdin
input = stdin.readline

def ccw(p1, p2, p3):
  return (p2[0]-p1[0])*(p3[1]-p1[1]) - (p2[1]-p1[1])*(p3[0]-p1[0])

def convex_haul(p):
  U = []; L = []; p.sort()
  for q in p:
    while len(U) > 1 and ccw(U[-2], U[-1], q) >= 0:
      U.pop()
    while len(L) > 1 and ccw(L[-2], L[-1], q) <= 0:
      L.pop()
    U.append(q); L.append(q)
  return U, L

def rot_cal(p):
  U, L = convex_haul(p)
  i = 0; j = len(L)-1
  i = 0; j = len(L)-1
  while i < len(U)-1 or j > 0:
    yield U[i],L[j]
    if i == len(U)-1:
      j -= 1
    elif j == 0:
      i += 1
    elif (U[i+1][1]-U[i][1]) * (L[j][0]-L[j-1][0]) > (L[j][1]-L[j-1][1])*(U[i+1][0]-U[i][0]):
      i += 1
    else: j-= 1

def distsq(ptup):
  p1, p2 = ptup
  x1, y1 = p1; x2, y2 = p2
  return (x2-x1)**2 + (y2-y1)**2

for _ in range(int(input())):
  n = int(input())
  p = [tuple(map(int, input().split())) for i in range(n)]
  q = max(rot_cal(p), key = distsq)
  print(q[0][0], q[0][1], q[1][0], q[1][1])
```

{% endtab %}
{% endtabs %}
