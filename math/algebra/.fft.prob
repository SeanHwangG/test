> baekjoon

* [Level 19 : 이동](https://www.acmicpc.net/problem/1067)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/algebra/fft/BJ_1067.md/)

{% tabs %}
{% tab title='BJ_1067.md' %}

> Question

* Find maximum convolution, if one array can be rotated

```txt
Input:
4
1 2 3 4
6 7 8 5

Output: 70
```

{% endtab %}
{% tab title='BJ_1067.py' %}

```py
from math import pi, sin, cos
def FFT(X, inv):
  n, j = len(X), 0
  for i in range(1, n):
    bit = n >> 1
    while j >= bit:
      j -= bit
      bit >>= 1
    j += bit
    if i < j:
      X[i], X[j] = X[j], X[i]
  d = 2
  while d<=n:
    ang = 2*pi/d
    if inv: ang =- ang
    dw = cos(ang) + sin(ang) * (1j)
    for i in range(0,n,d):
      w = 1
      for j in range(d//2):
        u,v=X[i+j],X[i+j+d//2]*w
        X[i+j],X[i+j+d//2]=u+v,u-v
        w*=dw
    d<<=1
  if inv:
    X = [x / n for x in X]
  return X
N = int(input())
n = 1
while n< 4 * N:
  n <<= 1
A0 = list(map(int,input().split()))
B = list(map(int,input().split()))[::-1] + [0] * (n-N)
A, R = [0] * n, [0] * n
for i in range(N):
  A[i]=A[i+N]=A0[i]
FFT(A, False)
FFT(B, False)
for i in range(n):
  R[i] = A[i] * B[i]
FFT(R, True)
print(max([round(abs(i)) for i in R]))
```

{% endtab %}
{% endtabs %}

* [Level 20 : 큰 수 곱셈 (2)](https://www.acmicpc.net/problem/15576)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/algebra/fft/BJ_15576.md/)

{% tabs %}
{% tab title='BJ_15576.md' %}

> Question

* implement a * b (they can be large)

```txt
Input: 893724358493284 238947328947329
Output: 213553048277135320552236238436
```

{% endtab %}
{% tab title='BJ_15576.py' %}

```cpp
#include<bits/stdc++.h>
using namespace std;

const double PI = acos(-1);
using cpx = complex<double>;
using poly = vector<cpx>;

void fft(poly& pol, cpx w){
  int n=pol.size();
  if (n==1) return;

  int i;

  poly e(n >> 1), o(n >> 1);
  for(i=0;i<n;++i){
    ((i & 1)? o: e)[i>>1]=pol[i];
  }

  fft(e, w*w);
  fft(o ,w*w);

  cpx p(1,0);
  for(i=0; i<(n>>1); ++i){
    pol[i] = e[i] + p * o[i];
    pol[i+(n>>1)] = e[i]-p*o[i];
    p *= w;
  }
}

poly mult(poly a,poly b){
  int n=1;
  for(;n<a.size()+1||n<b.size()+1; n<<=1);
  n<<=1;
  a.resize(n);
  b.resize(n);
  poly c(n);

  cpx w(cos(2*PI/n),sin(2*PI/n));

  fft(a,w);
  fft(b,w);

  int i=0;

  for(i=0;i<n;++i){
    c[i]=a[i]*b[i];
  }

  fft(c,cpx(1,0)/w);
  for(i=0;i<n;++i){
    c[i]/=cpx(n,0);
    c[i]=cpx(round(c[i].real()),round(c[i].imag()));
  }

  return c;
}

poly StoP(string s){
  poly r;
  for(int i= s.size() - 1;i >= 0; --i)
    r.push_back(cpx(s[i]-'0',0));
  return r;
}

int main(void){
  string a,b;
  cin >> a >> b;

  if(a == "0" || b == "0"){
    cout << 0;
    return 0;
  }

  poly r = mult(StoP(a),StoP(b));
  stack<int> st;
  int up = 0;
  for (cpx i: r){
    int rp = (int) i.real();
    st.push((rp % 10 + up) % 10);
    up = (rp + up) / 10;
  }

  int z = 1;
  while(!st.empty()){
    if(z && st.top()) z=0;
    if(!z)  cout<<st.top();
    st.pop();
  }
}
```

{% endtab %}
{% endtabs %}
