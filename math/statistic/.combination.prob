> baekjoon

* [Level 4 : 일곱 난쟁이](https://www.acmicpc.net/problem/2309)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_2309.md/)

{% tabs %}
{% tab title='BJ_2309.md' %}

> Question

* Out of 9 numbers, print 7 numbers that sums up to 100

```txt
Input:
7
8
10
13
15
19
20
23
25

Output:
7
8
10
13
19
20
23
```

{% endtab %}
{% tab title='BJ_2309.py' %}

```py
import itertools
li = [int(input()) for _ in range(9)]
for l in itertools.combinations(li, 7):
  if sum(l) == 100:
    print(*sorted(l), sep='\n')
    break
```

{% endtab %}
{% endtabs %}

* [Level 4 : 블랙잭](https://www.acmicpc.net/problem/2798)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_2798.md/)

{% tabs %}
{% tab title='BJ_2798.md' %}

> Question

* Print the sum of three cards as close as possible to M without exceeding M on the first line

```txt
Input: LOVA
Output: LOV
```

{% endtab %}
{% tab title='BJ_2798.py' %}

```py
import itertools
n, m = map(int, input().split())
li = list(map(int, input().split()))
ret = 0
for l in itertools.combinations(li, 3):
  if ret < sum(l) <= m:
    ret = sum(l)
print(ret)
```

{% endtab %}
{% endtabs %}

* [Level 4 : 백설 공주와 일곱 난쟁이](https://www.acmicpc.net/problem/3040)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_3040.md/)

{% tabs %}
{% tab title='BJ_3040.md' %}

> Question

* Out of 9 numbers, print 7 numbers that sums up to 100

```txt
Input:
7
8
10
13
15
19
20
23
25

Output:
7
8
10
13
19
20
23
```

{% endtab %}
{% tab title='BJ_3040.py' %}

```py
from itertools import combinations
for n in combinations([int(input()) for _ in [0] * 9], 7):
  if sum(n)==100:
    print(*n)
    break
```

{% endtab %}
{% endtabs %}

* [Level 5 : 적어도 대부분의 배수](https://www.acmicpc.net/problem/1145)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_1145.md/)

{% tabs %}
{% tab title='BJ_1145.md' %}

> Question

* There are five natural numbers
* Special number is the smallest natural number divided into at least three of the above numbers
* When given five different natural numbers, print special number

```txt
Input: 30 42 70 35 90
Output: 210
```

{% endtab %}
{% tab title='BJ_1145.py' %}

```py
from math import lcm
from itertools import combinations

print(min(lcm(a, b, c) for a, b, c in combinations(map(int, input().split()), 3)))
```

{% endtab %}
{% endtabs %}

* [Level 6 : 한윤정이 이탈리아에 가서 아이스크림을 사먹는데](https://www.acmicpc.net/problem/2422)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_2422.md/)

{% tabs %}
{% tab title='BJ_2422.md' %}

> Question

* All ice creams are numbered from 1 to N
* M, bad combination are given, which cannot be eaten at the same time
* how many ways to choose three types of icecream

```txt
Input:
5 3
1 2
3 4
1 3

Output: 3
```

{% endtab %}
{% tab title='BJ_2422.py' %}

```py
N, M = map(int, input().split())
no_mat_combi = []
for _ in range(M):
  no_mat_combi.append(list(map(int, input().split())))
no_mat = set()
for item in no_mat_combi:
  for i in range(1, N + 1):
    if i not in item:
      no_mat.add(tuple(sorted(item + [i])))
answer = int(N * (N - 1) * (N - 2) / 6 - len(no_mat))
print(answer)
```

{% endtab %}
{% endtabs %}

* [Level 8 : 과 M (2)](https://www.acmicpc.net/problem/15650)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_15650.md/)

{% tabs %}
{% tab title='BJ_15650.md' %}

> Question

* the sequence in which it selects M among the natural number from 1 to N without the duplication
* The sequences chosen should be in ascending order

```txt
Input: 4 2
Output:
1 2
1 3
1 4
2 3
2 4
3 4
```

{% endtab %}
{% tab title='BJ_15650.py' %}

```py
N, M = map(int, input().split())
def backtrack(cur, N, M):
  if len(cur) == M:
    print(*cur)
    return
  for i in range(cur[-1] + 1 if cur else 1, N + 1):
    cur.append(i)
    backtrack(cur, N, M)
    cur.pop()
backtrack([], N, M)
# for s in itertools.combinations(range(1, N + 1), M): print(*s)
```

{% endtab %}
{% endtabs %}

* [Level 9 : 부분수열의 합](https://www.acmicpc.net/problem/1182)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_1182.md/)

{% tabs %}
{% tab title='BJ_1182.md' %}

> Question

* Given N integers, find the number of subsequence that sums up to S

```txt
Input:
5 0
-7 -3 -2 5 8

Output: 1   # -3 -2 5
```

{% endtab %}
{% tab title='BJ_1182.py' %}

```py
from itertools import combinations
cnt = 0
n, s = map(int, input().split())
arr = [*map(int, input().split())]
for i in range(1, n + 1):
  for combination in combinations(arr,i):
    if sum(combination) == s:
      cnt += 1
print(cnt)
```

{% endtab %}
{% endtabs %}

* [Level 9 : 과 M (9)](https://www.acmicpc.net/problem/15663)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_15663.md/)

{% tabs %}
{% tab title='BJ_15663.md' %}

> Question

* The sequence of choosing M from N natural numbers

```txt
Input:
4 2
9 7 9 1

Output:
1 7
1 9
7 1
7 9
9 1
9 7
9 9
```

{% endtab %}
{% tab title='BJ_15663.py' %}

```py
N, M = map(int, input().split())
li = list(sorted(map(int, input().split())))
def backtrack(cur, N, M):
  if len(cur) == M:
    print(*cur)
    return
  for i in range(N):
    if (not cur or cur[-1] != li[i]) and li[i] != li[i - 1]:
      cur.append(li[i])
      backtrack(cur, N, M)
      cur.pop()
backtrack([], N, M)
```

{% endtab %}
{% endtabs %}

* [Level 9 : 로또](https://www.acmicpc.net/problem/6603)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_6603.md/)

{% tabs %}
{% tab title='BJ_6603.md' %}

> Question

* Given a set of S and k, finds all the ways to choose a number

```txt
Input:
7 1 2 3 4 5 6 7
8 1 2 3 5 8 13 21 34
0

Output:
1 2 3 4 5 6
1 2 3 4 5 7
1 2 3 4 6 7
1 2 3 5 6 7
1 2 4 5 6 7
1 3 4 5 6 7
2 3 4 5 6 7

1 2 3 5 8 13
1 2 3 5 8 21
1 2 3 5 8 34
1 2 3 5 13 21
1 2 3 5 13 34
1 2 3 5 21 34
1 2 3 8 13 21
1 2 3 8 13 34
1 2 3 8 21 34
1 2 3 13 21 34
1 2 5 8 13 21
1 2 5 8 13 34
1 2 5 8 21 34
1 2 5 13 21 34
1 2 8 13 21 34
1 3 5 8 13 21
1 3 5 8 13 34
1 3 5 8 21 34
1 3 5 13 21 34
1 3 8 13 21 34
1 5 8 13 21 34
2 3 5 8 13 21
2 3 5 8 13 34
2 3 5 8 21 34
2 3 5 13 21 34
2 3 8 13 21 34
2 5 8 13 21 34
3 5 8 13 21 34
```

{% endtab %}
{% tab title='BJ_6603.py' %}

```py
from itertools import combinations
while True:
  line = input()
  if line == "0":
    break
  li = line.split()[1:]
  for comb in combinations(li, 6):
    print(" ".join(comb))
  print()
```

{% endtab %}
{% endtabs %}

* [Level 10 : 도영이가 만든 맛있는 음식](https://www.acmicpc.net/problem/2961)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_2961.md/)

{% tabs %}
{% tab title='BJ_2961.md' %}

> Question

* Given N ingredients, we know its sourness S and bitterness B
* When using 1+ ingredients, sourness is product of all ingredients, while bitterness is sum of all ingredients
* Choose the ingredients so that the absolute difference between sourness and bitterness is the smallest

```txt
Input:
1
3 10

Output: 7

Input:
2
3 8
5 8

Output: 1
```

{% endtab %}
{% tab title='BJ_2961.py' %}

```py
from itertools import combinations
def f(i):
  v, w = 1, 0
  for x, y in i:
    v *= x
    w += y
  return abs(v-w)
n,r=int(input()),range
l = [[*map(int,input().split())]for i in r(n)]
print(min(f(j) for i in r(n) for j in combinations(l, i + 1)))
```

{% endtab %}
{% endtabs %}

* [Level 11 : 치킨 배달](https://www.acmicpc.net/problem/15686)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_15686.md/)

{% tabs %}
{% tab title='BJ_15686.md' %}

> Question

* Chicken streets are streets between house and nearest chicken house: chicken streets are set based on house
  * each house has chicken streets
* The city's chicken distance is the sum of all the home's chicken streets
* Find M chicken house that minimizes citie's chicken distance

```txt
Input:
5 3
0 0 1 0 0
0 0 2 0 1
0 1 2 0 0
0 0 1 0 0
0 0 0 0 2

Output: 5
```

{% endtab %}
{% tab title='BJ_15686.py' %}

```py
from itertools import combinations

N, M = map(int, input().split())
G = [list(map(int, input().split())) for _ in range(N)]

houses = []
chickens = []
for i in range(N):
  for j in range(N):
    if G[i][j] == 1:   houses.append((i, j))
    elif G[i][j] == 2: chickens.append((i, j))

minv = float('inf')
for ch in combinations(chickens, M):
  sumv = 0
  for house in houses:
    sumv += min([abs(house[0]-i[0])+abs(house[1]-i[1]) for i in ch])
    if minv <= sumv:
      break
  minv = min(minv, sumv)

print(minv)
```

{% endtab %}
{% endtabs %}

* [Level 11 : 암호 만들기](https://www.acmicpc.net/problem/1759)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_1759.md/)

{% tabs %}
{% tab title='BJ_1759.md' %}

> Question

* password is known to consist of at least one vowel and at least two consonants, consisting of different L lowercase letters
* It is also assumed that alphabet of ciphers may have been arranged in increasing order from ciphers
* given preference of the instructors for the sorted strings
* In other words, abc is a possible password, but bac is not

```txt
Input:
4 6
a t c i s w

Output:
acis
acit
aciw
acst
acsw
actw
aist
aisw
aitw
astw
cist
cisw
citw
istw
```

{% endtab %}
{% tab title='BJ_1759.py' %}

```py
from itertools import combinations
n, m = map(int, input().split())
li = sorted(input().split())
for c in combinations(li, n):
  count = 0
  for letter in c:
    if letter in "aeiou":
      count += 1
  if (count >= 1) and (count <= n-2):
    print(*c, sep ='')
```

{% endtab %}
{% endtabs %}

* [Level 14 : 벡터 매칭](https://www.acmicpc.net/problem/1007)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_1007.md/)

{% tabs %}
{% tab title='BJ_1007.md' %}

> Question

* Given points (< 20) print minimum vector sum

```txt
Input:
2
4
5 5
5 -5
-5 5
-5 -5
2
-100000 -100000
100000 100000

Output:
0.000000000000
282842.712474619038
```

{% endtab %}
{% tab title='BJ_1007.py' %}

```py
from itertools import combinations
from math import sqrt, inf

for i in range(int(input())):
  n = int(input())
  cords = []
  ans, xSum, ySum = inf, 0, 0
  for j in range(n):
    x, y = map(int, input().split())
    xSum, ySum = xSum + x, ySum + y
    cords.append([x, y])
  for c in (combinations(cords, int(n / 2))):
    tx = ty = 0
    for mx, my in c:
      tx, ty = tx + mx, ty + my
    ans = min(ans, sqrt((xSum - 2 * tx)**2 + (ySum - 2 * ty)**2))
  print(ans)
```

{% endtab %}
{% endtabs %}

> kattis

* [Level 1.6 : Patuljci](https://open.kattis.com/problems/patuljci)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/KT_patuljci.md/)

[Duplicate](./BJ_2309.md)

> leetcode

* [Level 2 : Combinations](https://leetcode.com/problems/combinations)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/LC_77.md/)

{% tabs %}
{% tab title='LC_77.md' %}

> Question

* Given n, k return all possible combinations of k numbers out of the range (1, n) in any order

```txt
Input: n = 4, k = 2
Output:
[ [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4], ]
```

Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].
You may return the answer in any order.

{% endtab %}
{% tab title='LC_77.py' %}

```py
def combine(self, n: int, k: int) -> List[List[int]]:
  if k == 0:
    return [[]]
  return [pre + [i] for i in range(k, n + 1) for pre in self.combine(i - 1, k - 1)]
```

{% endtab %}
{% endtabs %}

* [Level 2 : Subsets](https://leetcode.com/problems/subsets)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/LC_78.md/)

{% tabs %}
{% tab title='LC_78.md' %}

> Question

* Given an integer array nums of unique elements, return all possible subsets (the power set)

```txt
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

{% endtab %}
{% tab title='LC_78.cpp' %}

```cpp
vector<vector<int>> subsets(vector<int>& nums) {
  vector<vector<int>> subs = {{}};
  for (int num : nums) {
    for (int i = 0; i < subs.size(); i++) {
      subs.push_back(subs[i]);
      subs.back().push_back(num);
    }
  }
  return subs;
}
```

{% endtab %}
{% tab title='LC_78.py' %}

```py
def subsets(self, nums):
  return [l for n in range(len(nums) + 1) for l in itertools.combinations(nums, n)]
```

{% endtab %}
{% endtabs %}

* [Level 2 : Subsets II](https://leetcode.com/problems/subsets-ii)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/LC_90.md/)

{% tabs %}
{% tab title='LC_90.md' %}

> Question

* Given an integer array nums that may contain duplicates, return all possible subsets (the power set)

```txt
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
```

{% endtab %}
{% tab title='LC_90.cpp' %}

```cpp
class Solution {
public:
  vector<vector<int> > subsetsWithDup(vector<int> &S) {
    sort(S.begin(), S.end());
    vector<vector<int>> ret = {{}};
    int size = 0, startIndex = 0;
    for (int i = 0; i < S.size(); i++) {
      startIndex = i >= 1 && S[i] == S[i - 1] ? size : 0;
      size = ret.size();
      for (int j = startIndex; j < size; j++) {
        vector<int> temp = ret[j];
        temp.push_back(S[i]);
        ret.push_back(temp);
      }
    }
    return ret;
  }
};
```

{% endtab %}
{% tab title='LC_90.py' %}

```py
from itertools import compress, product
def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
  return set(tuple(compress(sorted(nums), bits)) for bits in product(range(2), repeat=len(nums)))
```

{% endtab %}
{% endtabs %}
