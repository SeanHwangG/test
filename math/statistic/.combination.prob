> baekjoon

* [Level  : UNKNOWN]()
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_1007.md/)

{% tabs %}
{% tab title='BJ_1007.md' %}

> Question

* Given points (< 20) print minimum vector sum

```txt
Input:
2
4
5 5
5 -5
-5 5
-5 -5
2
-100000 -100000
100000 100000

Output:
0.000000000000
282842.712474619038
```

{% endtab %}
{% tab title='BJ_1007.py' %}

```py
from itertools import combinations
from math import sqrt, inf

for i in range(int(input())):
  n = int(input())
  cords = []
  ans, xSum, ySum = inf, 0, 0
  for j in range(n):
    x, y = map(int, input().split())
    xSum, ySum = xSum + x, ySum + y
    cords.append([x, y])
  for c in (combinations(cords, int(n / 2))):
    tx = ty = 0
    for mx, my in c:
      tx, ty = tx + mx, ty + my
    ans = min(ans, sqrt((xSum - 2 * tx)**2 + (ySum - 2 * ty)**2))
  print(ans)
```

{% endtab %}
{% endtabs %}

* [Level 4 : 일곱 난쟁이](https://www.acmicpc.net/problem/2309)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_2309.md/)

{% tabs %}
{% tab title='BJ_2309.md' %}

> Question

* Out of 9 numbers, print 7 numbers that sums up to 100

```txt
Input:
7
8
10
13
15
19
20
23
25

Output:
7
8
10
13
19
20
23
```

{% endtab %}
{% tab title='BJ_2309.py' %}

```py
import itertools
li = [int(input()) for _ in range(9)]
for l in itertools.combinations(li, 7):
  if sum(l) == 100:
    print(*sorted(l), sep='\n')
    break
```

{% endtab %}
{% endtabs %}

* [Level 4 : 블랙잭](https://www.acmicpc.net/problem/2798)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_2798.md/)

{% tabs %}
{% tab title='BJ_2798.md' %}

> Question

* Print the sum of three cards as close as possible to M without exceeding M on the first line

```txt
Input: LOVA
Output: LOV
```

{% endtab %}
{% tab title='BJ_2798.py' %}

```py
import itertools
n, m = map(int, input().split())
li = list(map(int, input().split()))
ret = 0
for l in itertools.combinations(li, 3):
  if ret < sum(l) <= m:
    ret = sum(l)
print(ret)
```

{% endtab %}
{% endtabs %}

* [Level 4 : 백설 공주와 일곱 난쟁이](https://www.acmicpc.net/problem/3040)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_3040.md/)

{% tabs %}
{% tab title='BJ_3040.md' %}

> Question

* Out of 9 numbers, print 7 numbers that sums up to 100

```txt
Input:
7
8
10
13
15
19
20
23
25

Output:
7
8
10
13
19
20
23
```

{% endtab %}
{% tab title='BJ_3040.py' %}

```py
from itertools import*
for n in combinations([int(input()) for _ in [0] * 9], 7):
  if sum(n)==100:
    print(*n)
    break
```

{% endtab %}
{% endtabs %}

* [Level 5 : 적어도 대부분의 배수](https://www.acmicpc.net/problem/1145)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_1145.md/)

{% tabs %}
{% tab title='BJ_1145.md' %}

> Question

* There are five natural numbers
* Special number is the smallest natural number divided into at least three of the above numbers
* When given five different natural numbers, print special number

```txt
Input: 30 42 70 35 90
Output: 210
```

{% endtab %}
{% tab title='BJ_1145.py' %}

```py
from math import lcm
from itertools import combinations

print(min(lcm(a, b, c) for a, b, c in combinations(map(int, input().split()), 3)))
```

{% endtab %}
{% endtabs %}

* [Level 6 : 한윤정이 이탈리아에 가서 아이스크림을 사먹는데](https://www.acmicpc.net/problem/2422)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_2422.md/)

{% tabs %}
{% tab title='BJ_2422.md' %}

> Question

* All ice creams are numbered from 1 to N
* M, bad combination are given, which cannot be eaten at the same time
* how many ways to choose three types of icecream

```txt
Input:
5 3
1 2
3 4
1 3

Output: 3
```

{% endtab %}
{% tab title='BJ_2422.py' %}

```py
N, M = map(int, input().split())
no_mat_combi = []
for _ in range(M):
  no_mat_combi.append(list(map(int, input().split())))
no_mat = set()
for item in no_mat_combi:
  for i in range(1, N + 1):
    if i not in item:
      no_mat.add(tuple(sorted(item + [i])))
answer = int(N * (N - 1) * (N - 2) / 6 - len(no_mat))
print(answer)
```

{% endtab %}
{% endtabs %}

* [Level 8 : 과 M (2)](https://www.acmicpc.net/problem/15650)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_15650.md/)

{% tabs %}
{% tab title='BJ_15650.md' %}

> Question

* the sequence in which it selects M among the natural number from 1 to N without the duplication
* The sequences chosen should be in ascending order

```txt
Input: 4 2
Output:
1 2
1 3
1 4
2 3
2 4
3 4
```

{% endtab %}
{% tab title='BJ_15650.py' %}

```py
N, M = map(int, input().split())
def backtrack(cur, N, M):
  if len(cur) == M:
    print(*cur)
    return
  for i in range(cur[-1] + 1 if cur else 1, N + 1):
    cur.append(i)
    backtrack(cur, N, M)
    cur.pop()
backtrack([], N, M)
# for s in itertools.combinations(range(1, N + 1), M): print(*s)
```

{% endtab %}
{% endtabs %}

* [Level 9 : 부분수열의 합](https://www.acmicpc.net/problem/1182)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_1182.md/)

{% tabs %}
{% tab title='BJ_1182.md' %}

> Question

* Given N integers, find the number of subsequence that sums up to S

```txt
Input:
5 0
-7 -3 -2 5 8

Output: 1   # -3 -2 5
```

{% endtab %}
{% tab title='BJ_1182.py' %}

```py
from itertools import combinations
cnt = 0
n, s = map(int, input().split())
arr = [*map(int, input().split())]
for i in range(1, n + 1):
  for combination in combinations(arr,i):
    if sum(combination) == s:
      cnt += 1
print(cnt)
```

{% endtab %}
{% endtabs %}

* [Level 9 : 과 M (9)](https://www.acmicpc.net/problem/15663)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_15663.md/)

{% tabs %}
{% tab title='BJ_15663.md' %}

> Question

* The sequence of choosing M from N natural numbers

```txt
Input:
4 2
9 7 9 1

Output:
1 7
1 9
7 1
7 9
9 1
9 7
9 9
```

{% endtab %}
{% tab title='BJ_15663.py' %}

```py
N, M = map(int, input().split())
li = list(sorted(map(int, input().split())))
def backtrack(cur, N, M):
  if len(cur) == M:
    print(*cur)
    return
  for i in range(N):
    if (not cur or cur[-1] != li[i]) and li[i] != li[i - 1]:
      cur.append(li[i])
      backtrack(cur, N, M)
      cur.pop()
backtrack([], N, M)
```

{% endtab %}
{% endtabs %}

* [Level 9 : 과 M (12)](https://www.acmicpc.net/problem/15666)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_15666.md/)

{% tabs %}
{% tab title='BJ_15666.md' %}

> Question

* Choose M from N integers
* Print all combinations with decresing numbers where you can select same number multiple times

```txt
Input:
4 2
9 7 9 1

Output:
1 1
1 7
1 9
7 7
7 9
9 9
```

{% endtab %}
{% tab title='BJ_15666.py' %}

```py
from itertools import *
N = int(input().split()[1])
for p in combinations_with_replacement(sorted(set(map(int,input().split()))), N):
  print(*p)
```

{% endtab %}
{% endtabs %}

* [Level 9 : 로또](https://www.acmicpc.net/problem/6603)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_6603.md/)

{% tabs %}
{% tab title='BJ_6603.md' %}

> Question

* Given a set of S and k, finds all the ways to choose a number

```txt
Input:
7 1 2 3 4 5 6 7
8 1 2 3 5 8 13 21 34
0

Output:
1 2 3 4 5 6
1 2 3 4 5 7
1 2 3 4 6 7
1 2 3 5 6 7
1 2 4 5 6 7
1 3 4 5 6 7
2 3 4 5 6 7

1 2 3 5 8 13
1 2 3 5 8 21
1 2 3 5 8 34
1 2 3 5 13 21
1 2 3 5 13 34
1 2 3 5 21 34
1 2 3 8 13 21
1 2 3 8 13 34
1 2 3 8 21 34
1 2 3 13 21 34
1 2 5 8 13 21
1 2 5 8 13 34
1 2 5 8 21 34
1 2 5 13 21 34
1 2 8 13 21 34
1 3 5 8 13 21
1 3 5 8 13 34
1 3 5 8 21 34
1 3 5 13 21 34
1 3 8 13 21 34
1 5 8 13 21 34
2 3 5 8 13 21
2 3 5 8 13 34
2 3 5 8 21 34
2 3 5 13 21 34
2 3 8 13 21 34
2 5 8 13 21 34
3 5 8 13 21 34
```

{% endtab %}
{% tab title='BJ_6603.py' %}

```py
from itertools import combinations
while True:
  line = input()
  if line == "0":
    break
  li = line.split()[1:]
  for comb in combinations(li, 6):
    print(" ".join(comb))
  print()
```

{% endtab %}
{% endtabs %}

* [Level 11 : 치킨 배달](https://www.acmicpc.net/problem/15686)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_15686.md/)

{% tabs %}
{% tab title='BJ_15686.md' %}

> Question

* Chicken streets are streets between house and nearest chicken house: chicken streets are set based on house
  * each house has chicken streets
* The city's chicken distance is the sum of all the home's chicken streets
* Find M chicken house that minimizes citie's chicken distance

```txt
Input:
5 3
0 0 1 0 0
0 0 2 0 1
0 1 2 0 0
0 0 1 0 0
0 0 0 0 2

Output: 5
```

{% endtab %}
{% tab title='BJ_15686.py' %}

```py
from itertools import combinations

N, M = map(int, input().split())
G = [list(map(int, input().split())) for _ in range(N)]

houses = []
chickens = []
for i in range(N):
  for j in range(N):
    if G[i][j] == 1:   houses.append((i, j))
    elif G[i][j] == 2: chickens.append((i, j))

minv = float('inf')
for ch in combinations(chickens, M):
  sumv = 0
  for house in houses:
    sumv += min([abs(house[0]-i[0])+abs(house[1]-i[1]) for i in ch])
    if minv <= sumv:
      break
  minv = min(minv, sumv)

print(minv)
```

{% endtab %}
{% endtabs %}

* [Level 11 : 암호 만들기](https://www.acmicpc.net/problem/1759)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/BJ_1759.md/)

{% tabs %}
{% tab title='BJ_1759.md' %}

> Question

* password is known to consist of at least one vowel and at least two consonants, consisting of different L lowercase letters
* It is also assumed that alphabet of ciphers may have been arranged in increasing order from ciphers
* given preference of the instructors for the sorted strings
* In other words, abc is a possible password, but bac is not

```txt
Input:
4 6
a t c i s w

Output:
acis
acit
aciw
acst
acsw
actw
aist
aisw
aitw
astw
cist
cisw
citw
istw
```

{% endtab %}
{% tab title='BJ_1759.py' %}

```py
from itertools import combinations
n, m = map(int, input().split())
li = sorted(input().split())
for c in combinations(li, n):
  count = 0
  for letter in c:
    if letter in "aeiou":
      count += 1
  if (count >= 1) and (count <= n-2):
    print(*c, sep ='')
```

{% endtab %}
{% endtabs %}

> kattis

* [Level 1.6 : Patuljci](https://open.kattis.com/problems/patuljci)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/KT_patuljci.md/)

[Duplicate](./BJ_2309.md)

> leetcode

* [Level 2 : Combinations](https://leetcode.com/problems/combinations)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/combination/LC_77.md/)

{% tabs %}
{% tab title='LC_77.md' %}

> Question

* Given n, k return all possible combinations of k numbers out of the range (1, n) in any order

```txt
Input: n = 4, k = 2
Output:
[ [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4], ]
```

Given two integers n and k, return all possible combinations of k numbers out of the range [1, n].
You may return the answer in any order.

{% endtab %}
{% tab title='LC_77.py' %}

```py
def combine(self, n: int, k: int) -> List[List[int]]:
  if k == 0:
    return [[]]
  return [pre + [i] for i in range(k, n + 1) for pre in self.combine(i - 1, k - 1)]
```

{% endtab %}
{% endtabs %}
