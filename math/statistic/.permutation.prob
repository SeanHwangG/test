> baekjoon

* [Level 6 : 카드 놓기](https://www.acmicpc.net/problem/5568)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/permutation/BJ_5568.md/)

{% tabs %}
{% tab title='BJ_5568.md' %}

> Question

* Print number of ways can be made by concatnating given integers

```txt
Input:
4
2
1
2
12
1

Output:
7  # 11, 12, 21, 112, 121, 122, 212
```

{% endtab %}
{% tab title='BJ_5568.py' %}

```py
from itertools import *

n, k = int(input()), int(input())
print(len({''.join(v) for v in permutations((input() for _ in range(n)), k)}))
```

{% endtab %}
{% endtabs %}

* [Level 8 : 다음 순열](https://www.acmicpc.net/problem/10972)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/permutation/BJ_10972.md/)

{% tabs %}
{% tab title='BJ_10972.md' %}

> Question

* a permutation consisting of numbers from 1 to N, find the permutations that follow in alphabetical order

```txt
Input:
4
1 2 3 4
Output: 1 2 4 3
```

{% endtab %}
{% tab title='BJ_10972.cpp' %}

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
  int num, a;
  cin >> num;
  vector<int> v;
  for (int i = 0; i < num; i++) {
    cin >> a;
    v.push_back(a);
  }

  if (next_permutation(v.begin(), v.end()))
    for (int i = 0; i < v.size(); i++)
      cout << v[i] << " ";
  else
    cout << -1;

  return 0;
}
```

{% endtab %}
{% tab title='BJ_10972.py' %}

```py
N = int(input())
A = list(map(int, input().split()))

i = N-1
while i>0 and A[i-1]>A[i]:
  i -= 1

if i == 0:
  print(-1)
  exit()

j = N-1
while A[i-1]>A[j]:
  j -= 1

A[i-1], A[j] = A[j], A[i-1]
print(*(A[:i]+list(reversed(A[i:]))))
```

{% endtab %}
{% endtabs %}

* [Level 8 : 이전 순열](https://www.acmicpc.net/problem/10973)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/permutation/BJ_10973.md/)

{% tabs %}
{% tab title='BJ_10973.md' %}

> Question

* print previous permutation (-1 if first)

```txt
Input:
5
5 4 3 2 1

Output:
5 4 3 1 2
```

{% endtab %}
{% tab title='BJ_10973.py' %}

```cpp
#include <bits/stdc++.h>

using namespace std;

int N,ar[11000];
int main() {
  cin>>N;
  for (int x=0; x<N; x++) cin>>ar[x];
  if (prev_permutation(ar,ar+N)) {
    for(int x=0; x<N; x++)
      cout << ar[x] << " ";
  }
  else cout << "-1";
}
```

{% endtab %}
{% endtabs %}

* [Level 8 : 모든 순열](https://www.acmicpc.net/problem/10974)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/permutation/BJ_10974.md/)

{% tabs %}
{% tab title='BJ_10974.md' %}

> Question

* Print every permutation

```txt
Input: 3

Output:
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

{% endtab %}
{% tab title='BJ_10974.py' %}

```py
from itertools import permutations
n = int(input())
for k in permutations(range(1,n+1),n):
  print(*k)
```

{% endtab %}
{% endtabs %}

* [Level 9 : 차이를 최대로](https://www.acmicpc.net/problem/10819)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/permutation/BJ_10819.md/)

{% tabs %}
{% tab title='BJ_10819.md' %}

> Question

* An array of N integers is given
* At this time, obtain the maximum value of the following formula by changing the order of the integers in the array

$$ |A[0]-A[1]|+|A[1]-A[2]|+\ldots+|A[N-2]-A[N-1]| $$

```txt
Input:
6
20 1 15 8 4 10

Output: 62
```

{% endtab %}
{% tab title='BJ_10819.py' %}

```py
from itertools import permutations
n = int(input())
arr = permutations(list(map(int, input().split(' '))))
ans = 0
for a in arr:
  sums = 0
  for i in range(n-1):
    sums += abs(a[i]-a[i+1])
  ans = max(ans, sums)
print(ans)
```

{% endtab %}
{% endtabs %}

* [Level 10 : 연산자 끼워넣기](https://www.acmicpc.net/problem/14888)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/permutation/BJ_14888.md/)

{% tabs %}
{% tab title='BJ_14888.md' %}

> Question

* The sequence A1, A2, ... and AN consisting of N numbers is given
* N-1 operators that can be inserted between numbers (addition (+), subtraction (-), multiplication (×), and division (/)
* Given the number of N and N-1 operators, obtain the maximum and minimum results of the expression you can make

```txt
Input:
3
3 4 5
1 0 1 0

Output:
35    # (3 + 4) * 5
17    # 3 * 4 + 5
```

{% endtab %}
{% tab title='BJ_14888.py' %}

```py
from itertools import permutations
N = int(input())
A = list(map(int, input().split()))
a, s, m, d = map(int, input().split())
mn, mx = float('inf'), -float('inf')
for p in set(permutations('+'*a+'-'*s+'*'*m+'/'*d)):
  r = A[0]
  for i in range(1, N):
    r = {'+': r+A[i], '-': r-A[i], '*': r*A[i], '/': int(r/A[i])}[p[i-1]]
  mn = min(mn, r)
  mx = max(mx, r)
print(mx)
print(mn)
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 2 : Minimum Adjacent Swaps to Reach the Kth Smallest Number](https://leetcode.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/permutation/LC_1850.md/)

{% tabs %}
{% tab title='LC_1850.md' %}

> Question

* Given a string num, representing a large integer, and an integer k
* integer is wonderful if it's a permutation of the digits in num and is greater in value than num
* Return the minimum number of adjacent digit swaps that needs to be applied to num to reach the kth smallest wonderful integer

```txt
Input: num = "11112", k = 4
Output: 4
```

{% endtab %}
{% tab title='LC_1850.cpp' %}

```cpp
int getMinSwaps(string num, int k) {
  string next = num;
  while (next_permutation(next.begin(), next.end()) && --k);
  int ans = 0;
  for (int i = 0; i < num.length() - 1; i++)
    if (num[i] != next[i]) {
      int j = i+1;
      while (num[i] != next[j]) j++;
      for (int k = j; k > i; k--){
        swap(next[k], next[k - 1]);
        ans++;
      }
    }
  return ans;
}
```

{% endtab %}
{% endtabs %}

* [Level 2 : Next Permutation](https://leetcode.com/problems/next-permutation)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/permutation/LC_31.md/)

{% tabs %}
{% tab title='LC_31.md' %}

> Question

* Print next permutation

```txt
Input: nums = [1,2,3]
Output: [1,3,2]
```

{% endtab %}
{% tab title='LC_31.cpp' %}

```cpp
void nextPermutation(vector<int>& nums) {
  next_permutation(begin(nums), end(nums));
}
```

{% endtab %}
{% tab title='LC_31.py' %}

```py
def nextPermutation(self, nums):
  i = j = len(nums)-1   # 1: find sorted until
  while i > 0 and nums[i-1] >= nums[i]:
    i -= 1
  if i == 0:
    nums.reverse()
    return
  k = i - 1  # find the last "ascending" position
  while nums[j] <= nums[k]:
    j -= 1
  nums[k], nums[j] = nums[j], nums[k]
  l, r = k+1, len(nums)-1  # reverse the second part
  while l < r:
    nums[l], nums[r] = nums[r], nums[l]
    l +=1 ; r -= 1
```

{% endtab %}
{% endtabs %}

* [Level 3 : Permutation Sequence](https://leetcode.com/problems/permutation-sequence)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/permutation/LC_60.md/)

{% tabs %}
{% tab title='LC_60.md' %}

> Question

* Find kth permutation from the set [1, 2, ...]

```txt
Input: n = 3, k = 3
Output: "213"
```

{% endtab %}
{% tab title='LC_60.py' %}

```py
class Solution:
  def getPermutation(self, n: int, k: int) -> str:
    elements = list(range(1, n+1))
    NN = reduce(operator.mul, elements) # n!
    k, result = (k - 1) % NN, ''
    while len(elements) > 0:
      NN //= len(elements)
      i, k = k // NN, k % NN
      result += str(elements.pop(i))
    return result
```

{% endtab %}
{% endtabs %}

* [Level 3 : 24 Game](https://leetcode.com/problems/24-game)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/math/statistic/permutation/LC_679.md/)

{% tabs %}
{% tab title='LC_679.md' %}

> Question

* Given an integer array cards of length 4 each containing a number in the range [1, 9]
* Arrange numbers on these cards in a mathematical expression using ['+', '-', '*', '/', '(' and ')' to get 24

```txt
Input: cards = [4,1,8,7]
Output: true  # (8-4) * (7-1) = 24

Input: cards = [1,2,1,2]
Output: false
```

{% endtab %}
{% tab title='LC_679.py' %}

```py
def judgePoint24(self, nums: List[int]) -> bool:
  if len(nums) == 1:
    return math.isclose(nums[0], 24)
  return any(self.judgePoint24([x] + rest)
             for a, b, *rest in itertools.permutations(nums)
             for x in {a + b, a - b, a * b, b and a/b})
```

{% endtab %}
{% endtabs %}
