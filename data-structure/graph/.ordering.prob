> baekjoon

* [Level 12 : 작업](https://www.acmicpc.net/problem/2056)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/ordering/BJ_2056.md/)

{% tabs %}
{% tab title='BJ_2056.md' %}

> Question

* print minimum number of time to finish all jobs

```txt
Input:
7
5 0
1 1 1
3 1 2
6 1 1
1 2 2 4
8 2 2 4
4 3 3 5 6

Output: 23
```

{% endtab %}
{% tab title='BJ_2056.py' %}

```py
cost = [0]*10001

for i in range(1, int(input())+1):
  cost[i], *prior = map(int, input().split())
  cost[i] += max(cost[p] for p in prior)

print(max(cost))
```

{% endtab %}
{% endtabs %}

* [Level 13 : CM Craft](https://www.acmicpc.net/problem/1005)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/ordering/BJ_1005.md/)

{% tabs %}
{% tab title='BJ_1005.md' %}

> Question

* N is given the number of buildings and K is the total number of construction sequence rules between buildings
* Find minimum time to finish last building

```txt
Input:
2
4 4
10 1 100 10
1 2
1 3
2 4
3 4
4
8 8
10 20 1 5 8 7 1 43
1 2
1 3
2 4
2 5
3 6
5 7
6 7
7 8
7

Output:
120
39
```

{% endtab %}
{% tab title='BJ_1005.py' %}

```py
import sys
input = sys.stdin.readline

def topologicalSort(G):
  indegree = [0] * N
  for dic in G:
    for adj in dic.keys():
      indegree[adj] += 1

  order, id2cost = [], [0] * N
  for i in range(N):
    if indegree[i] == 0:
      id2cost[i] = D[i]
      order.append(i)
  for v in order:
    for adj, cost in G[v].items():
      id2cost[adj] = max(id2cost[adj], id2cost[v] + cost)
      indegree[adj] -= 1
      if indegree[adj] == 0:
        order.append(adj)
  return id2cost

T = int(input())
for _ in range(T):
  N, K = map(int, input().split())
  D = list(map(int, input().split()))
  G = [{} for _ in range(N)]
  for _ in range(K):
    X, Y = map(int, input().split())
    G[X - 1][Y - 1] = D[Y - 1]

  W = int(input()) - 1
  print(topologicalSort(G)[W])
```

{% endtab %}
{% endtabs %}

* [Level 13 : 게임 개발](https://www.acmicpc.net/problem/1516)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/ordering/BJ_1516.md/)

{% tabs %}
{% tab title='BJ_1516.md' %}

> Question

* first line is given the number of kind N (1 N 500) of building
* next N rows is time it takes to build each building and # buildings that must be built first to build that building
* Find time to build N building

```txt
Input:
5
10 -1
10 1 -1
4 1 -1
4 3 1 -1
3 3 -1

Output:
10
20
14
18
17
```

{% endtab %}
{% tab title='BJ_1516.py' %}

```py
N, costs = int(input()), []
G, G_r  = [[] for i in range(N)], [[] for i in range(N)]
wait = [0] * N
for u in range(N):
  li = list(map(int, input().split()))
  costs.append(li[0])
  for v in li[1:-1]:
    G[v - 1].append(u)
    G_r[u].append(v - 1)
    wait[u] += 1

bfs = [n for n in range(N) if wait[n] == 0]
for i in bfs:
  for j in G[i]:
    wait[j] -= 1
    if wait[j] == 0:
      bfs.append(j)
for i in bfs:
  costs[i] += max([0] + [costs[j] for j in G_r[i]])
print(*costs, sep='\n')
```

{% endtab %}
{% endtabs %}

* [Level 14 : 줄 세우기](https://www.acmicpc.net/problem/2252)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/ordering/BJ_2252.md/)

{% tabs %}
{% tab title=BJ_2252.md'BJ_2252.py' %}

> Quesiton

* Given pairs of compaison, sort them

```txt
Input:
3 2
1 3
2 3

Output: 1 2 3
```

{% endtab %}
{% tab title='' %}

```py
N, M = map(int, input().split())
G = [[] for i in range(N + 1)]
wait = [-1] + [0] * (N)
for _ in range(M):
  u, v = map(int, input().split())
  G[u].append(v)
  wait[v] += 1

bfs = [n for n in range(N + 1) if wait[n] == 0]
print(*bfs, end=' ')
for i in bfs:
  for j in G[i]:
    wait[j] -= 1
    if wait[j] == 0:
      print(j, end=' ')
      bfs.append(j)
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 2 : Course Schedule](https://leetcode.com/problems/course-schedule)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/ordering/LC_207.md/)

{% tabs %}
{% tab title='LC_207.md' %}

> Question

* Given jobs and prerequisite, check if all jobs can be done

```txt
Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
```

{% endtab %}
{% tab title='LC_207.py' %}

```py
def canFinish(n, prerequisites):
  G = [[] for i in range(n)]
  degree = [0] * n
  for i, j in prerequisites:
    G[i].append(j)                                                # Take i before j
    degree[j] += 1
  bfs = [i for i in range(n) if degree[i] == 0]
  for i in bfs:
    for j in G[i]:
      degree[j] -= 1
      if degree[j] == 0:
        bfs.append(j)
  return len(bfs) == n
```

{% endtab %}
{% endtabs %}

* [Level 2 : Course Schedule II](https://leetcode.com/problems/course-schedule-ii)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/ordering/LC_210.md/)

{% tabs %}
{% tab title='LC_210.md' %}

> Question

* There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1
* an array prerequisites where prerequisites[i] = [ai, bi] indicates that take course bi first before course ai
* Return any ordering of courses to finish all courses (if impossible, return an empty array)

```txt
Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
```

{% endtab %}
{% tab title='LC_210.py' %}

```py
def findOrder(self, n: int, prerequisites: List[List[int]]) -> List[int]:
  G = [[] for i in range(n)]
  degree = [0] * n
  for i, j in prerequisites:
    G[i].append(j)  # Take i before j
    degree[j] += 1
  bfs = [i for i in range(n) if degree[i] == 0]
  for i in bfs:
    for j in G[i]:
      degree[j] -= 1
      if degree[j] == 0:
        bfs.append(j)
  return reversed(bfs) if len(bfs) == n else []
```

{% endtab %}
{% endtabs %}

* [Level 3 : Alien Dictionary](https://leetcode.com/problems/alien-dictionary)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/ordering/LC_269.md/)

{% tabs %}
{% tab title='LC_269.md' %}

> Question

* There is a new alien language that uses the English alphabet. However, the order among the letters is unknown to you.
* Given a list of strings words from alien language's dictionary, with sorted string by rules of this new language

```txt
Input: words = ["wrt","wrf","er","ett","rftt"]
Output: "wertf"

Input: words = ["z","x","z"]
Output: ""  # The order is invalid, so return "".
```

{% endtab %}
{% tab title='LC_269.py' %}

```py
def alienOrder(self, words):
  pre, suc = defaultdict(set), defaultdict(set)
  for pair in zip(words, words[1:]):
    for a, b in zip(*pair):
      if a != b:
        suc[a].add(b)
        pre[b].add(a)
        break
    else:
      if len(pair[0]) > len(pair[1]):
        return ''
  chars, order = set(''.join(words)), []
  free = chars - set(pre)
  while free:
    a = free.pop()
    order.append(a)
    for b in suc[a]:
      pre[b].discard(a)
      if not pre[b]:
        free.add(b)
  return ''.join(order) * (set(order) == chars)
```

{% endtab %}
{% endtabs %}
