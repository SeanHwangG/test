> baekjoon

* [Level 9 : 외판원 순회 2](https://www.acmicpc.net/problem/10971)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/tsp/BJ_10971.md/)

{% tabs %}
{% tab title='BJ_10971.md' %}

> Question

* The cost of moving in each city time is given in the form of a matrix W[i][j]
* Given the N and cost matrix, find the lowest-cost traveling route for the salesman

```txt
Input:
4
0 10 15 20
5 0 9 10
6 13 0 12
8 8 9 0

Output: 35
```

{% endtab %}
{% tab title='BJ_10971.py' %}

```py
from functools import lru_cache
N = int(input())
G = []
for _ in range(N):
  G.append(list(map(int,input().split())))

@lru_cache(None)
def find_path(cur, visited):
  if visited == (1 << N) - 1:
    return G[cur][0] or float('inf')

  mn = float('inf')
  for nxt in range(N):
    if visited & (1 << nxt) == 0 and G[cur][nxt] != 0:
      mn = min(mn, find_path(nxt, visited | (1 << nxt)) + G[cur][nxt])
  return mn

print(find_path(0, 1))
```

{% endtab %}
{% endtabs %}

* [Level 14 : 우주 탐사선](https://www.acmicpc.net/problem/17182)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/tsp/BJ_17182.md/)

{% tabs %}
{% tab title='BJ_17182.md' %}

> Question

* Find TSP if one vertex can be visited multiple times and starting point can be diffreent from ending point (N < 10)

```txt
Input:
3 0
0 30 1
1 0 29
28 1 0

Output: 2
```

{% endtab %}
{% tab title='BJ_17182.py' %}

```py
from itertools import permutations

n, k = map(int,input().split())
T = [list(map(int,input().split())) for i in range(n)]
vis = list(range(n))
vis.remove(k)

for A in range(n):
  for i in range(n):
    for j in range(n):
      T[i][j] = min(T[i][j], T[i][A]+T[A][j])

ans = 10**15
for P in permutations(vis, n-1):
  cost = T[k][P[0]] + sum(T[P[i]][P[i+1]] for i in range(n-2))
  ans = min(ans, cost)
print(ans)
```

{% endtab %}
{% endtabs %}

* [Level 15 : 외판원 순회 3](https://www.acmicpc.net/problem/16991)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/tsp/BJ_16991.md/)

{% tabs %}
{% tab title='BJ_16991.md' %}

> Question

* Given points in 2D grids, print tsp distance

```txt
Input:
4
1 1
5 3
3 1
3 3

Output: 9.656854249
```

{% endtab %}
{% tab title='BJ_16991.py' %}

```py
from functools import lru_cache
N = int(input())
P = [tuple(map(int, input().split())) for _ in range(N)]
G = [[((P[i][0] - P[j][0]) ** 2 + (P[i][1] - P[j][1]) ** 2) ** 0.5 for i in range(N)] for j in range(N)]
@lru_cache(None)
def dfs(cur, visited):
  if visited == (1 << N) - 1:
    return G[cur][0]
  mn = float("inf")
  for nxt in range(N):
    if visited & 1 << nxt == 0:
      mn = min(mn, dfs(nxt, visited | (1 << nxt)) + G[cur][nxt])
  return mn
print(dfs(0, 1))
```

{% endtab %}
{% endtabs %}

* [Level 15 : 외판원 순회](https://www.acmicpc.net/problem/2098)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/tsp/BJ_2098.md/)

{% tabs %}
{% tab title='BJ_2098.md' %}

> Question

* The cost of moving between each city is given in the form of matrix W[i][j]
* W[i][j] represents the cost of going from city i to city j. Cost is not symmetrical
* In some cases, you can not go from city i to city j, W[i][j]=0

```txt
Input:
4
0 10 15 20
5 0 9 10
6 13 0 12
8 8 9 0

Output: 35
```

{% endtab %}
{% tab title='BJ_2098.py' %}

```py
N=int(input())
G=[]
INF=float('inf')
for _ in range(N):
  G.append(list(map(int,input().split())))

def find_path(last, visited, dp):
  if visited == (1<<N) - 1:
    return G[last][0] or INF

  if dp[last][visited] is not None:
    return dp[last][visited]

  tmp=INF
  for city in range(N):
    if visited & (1 << city) == 0 and G[last][city] != 0:
      tmp=min(tmp, find_path(city, visited | (1<<city), dp) + G[last][city])
  dp[last][visited]=tmp
  return tmp
dp = [[None]*(1<<N) for _ in range(N)]  # dp[a][b] = current node a, visited nodes bit

print(find_path(0, 1, dp))
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 3 : Find the Shortest Superstring](https://leetcode.com/problems/find-the-shortest-superstring)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/tsp/LC_943.md/)

{% tabs %}
{% tab title='LC_943.md' %}

> Question

* Given an array of strings words, return the smallest string that contains each string in words as a substring
* If there are multiple valid strings of the smallest length, return any of them
* You may assume that no string in words is a substring of another string in words

```txt
Input: words = ["catg","ctaagt","gcta","ttca","atgcatc"]
Output: "gctaagttcatgcatc"
```

{% endtab %}
{% tab title='LC_943.py' %}

```py
def shortestSuperstring(self, words: List[str]) -> str:
  overlaps = [[0 for _ in range(len(words))] for _ in range(len(words))]
  for i, cur in enumerate(words):
    for j, nxt in enumerate(words):
      for k in range(1, len(cur)):
        if nxt.startswith(cur[k:]):
          overlaps[i][j] = len(cur) - k
          break

  @lru_cache(None)
  def dfs(i, mask):
    if mask == (1 << len(words)) - 1:
      return words[i]
    ans = '#' * 320
    for j in range(len(words)):
      if mask & (1 << j) == 0:
        string = dfs(j, mask | (1 << j))
        ans = min(ans, words[i] + string[overlaps[i][j]:], key = len)
    return ans

  return min([dfs(i, 1<<i) for i in range(len(words))], key=len)
```

{% endtab %}
{% endtabs %}
