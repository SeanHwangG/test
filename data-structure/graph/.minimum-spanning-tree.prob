> baekjoon

* [Level 12 : 최소 스패닝 트리](https://www.acmicpc.net/problem/1197)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/minimum-spanning-tree/BJ_1197.md/)

{% tabs %}
{% tab title='BJ_1197.md' %}

> Question

* Given a graph, obtain the minimum spanning tree of the graph

```txt
Input:
3 3
1 2 1
2 3 2
1 3 3

Output: 3
```

{% endtab %}
{% tab title='BJ_1197.py' %}

```py
class UF:
  def __init__(self, N):
    self.parent = list(range(N))
    self.size = [1] * N

  def find(self, x):
    if self.parent[x] != x:
      self.parent[x] = self.find(self.parent[x])
    return self.parent[x]
  def union(self, x, y):
    px, py = self.find(x), self.find(y)
    if px != py:
      size_x, size_y = self.size[px], self.size[py]
      if size_x < size_y:
        self.parent[px] = py
        self.size[py] += size_x
      else:
        self.parent[py] = px
        self.size[px] += size_y
V, E = map(int, input().split())
uf = UF(V)
weight_u_v = []
for _ in range(E):
  u, v, w = map(int, input().split())
  weight_u_v.append((w, u - 1, v - 1))
total = 0
weight_u_v.sort()
for weight, u, v in weight_u_v:
  if uf.find(u) != uf.find(v):
    total += weight
    uf.union(u, v)

print(total)
```

{% endtab %}
{% endtabs %}

* [Level 12 : 네트워크 연결](https://www.acmicpc.net/problem/1922)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/minimum-spanning-tree/BJ_1922.md/)

{% tabs %}
{% tab title='BJ_1922.md' %}

> Question

* When given the necessary costs to connect each computer
* output the minimum cost required to connect all computers
* there is no case that all computers cannot be connected

```txt
Input:
6
9
1 2 5
1 3 4
2 3 2
2 4 7
3 4 6
3 5 11
4 5 3
4 6 8
5 6 8

Output: 23
```

{% endtab %}
{% tab title='BJ_1922.py' %}

```py
import heapq
n,  m = int(input()), int(input())
G = [[] for _ in range(n)]
for _ in range(m):
  s, e, c = map(int, input().split())
  G[s-1].append([e-1, c])
  G[e-1].append([s-1, c])
key = [0] + [float('inf')] * (n - 1)
visited = [False] * n
pq = []
heapq.heappush(pq, (0, 0))
result = 0
while pq:
  k, u = heapq.heappop(pq)
  if visited[u]:
    continue
  visited[u] = True
  result += k
  for dest, w in G[u]:
    if not visited[dest] and w < key[dest]:
      key[dest] = w
      heapq.heappush(pq, (key[dest], dest))
print(result)
```

{% endtab %}
{% endtabs %}

* [Level 20 : 그래프와 M](https://www.acmicpc.net/problem/15481)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/minimum-spanning-tree/BJ_15481.md/)

{% tabs %}
{% tab title='BJ_15481.md' %}

> Question

* Given Graph find minimum spanning tree that contains edge (u, v)

```txt
Input:
5 8
1 2 5
2 3 4
1 3 2
3 4 8
4 5 3
3 5 6
1 4 9
2 5 1

Output:
11
10
10
14
10
12
15
10
```

> Solution

* For query u, v, remove largest edge from u to v and add u, v
* Using LCA

{% endtab %}
{% tab title='BJ_15481.py' %}

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mxN = 2e5;

struct edge { int u, v, w, i; };
edge e[mxN];
int ans[mxN];

struct disjoint_set {
  int mst;
  vector<int> par, dist;
  disjoint_set(int n) {
    mst = 0;
    par.resize(n, -1);
    dist.resize(n, 0x3f3f3f3f);
  }
  int find(int u) {
    while (par[u] >= 0) u = par[u];
    return u;
  }
  void merge(edge& e) {
    int u = find(e.u), v = find(e.v);
    if (u == v) return;
    if (par[u] > par[v]) swap(u, v);
    par[u] += par[v];
    par[v] = u;
    dist[v] = e.w;
    mst += e.w;
  }
  int query(int u, int v) {
    int ans;
    for (; u != v; u = par[u]) {
      if (dist[u] > dist[v]) swap(u, v);
      ans = dist[u];
    }
    return ans;
  }
};
int main() {
  ios_base::sync_with_stdio(false); cin.tie(nullptr);
  int N, M; cin >> N >> M;

  for (int i = 0; i < M; ++i) {
    cin >> e[i].u >> e[i].v >> e[i].w; --e[i].u, --e[i].v;
    e[i].i = i;
  }

  sort(e, e + M, [&](auto& a, auto& b) { return a.w < b.w; });
  disjoint_set dsu(N);
  for (int i = 0; i < M; ++i) dsu.merge(e[i]);
  for (int i = 0; i < M; ++i) ans[e[i].i] = e[i].w - dsu.query(e[i].u, e[i].v);
  for (int i = 0; i < M; ++i) cout << dsu.mst + ans[i] << '\n';
}
```

{% endtab %}
{% endtabs %}
