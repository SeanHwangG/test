> baekjoon

* [Level 10 : 경로 찾기](https://www.acmicpc.net/problem/11403)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/floyd/BJ_11403.md/)

{% tabs %}
{% tab title='BJ_11403.md' %}

> Question

* Given an unweighted directed graph G, for all vertices (i, j), determine whether there is a path from i to j

```txt
Input:
7
0 0 0 1 0 0 0
0 0 0 0 0 0 1
0 0 0 0 0 0 0
0 0 0 0 1 1 0
1 0 0 0 0 0 0
0 0 0 0 0 0 1
0 0 1 0 0 0 0

Output:
1 0 1 1 1 1 1
0 0 1 0 0 0 1
0 0 0 0 0 0 0
1 0 1 1 1 1 1
1 0 1 1 1 1 1
0 0 1 0 0 0 1
0 0 1 0 0 0 0
```

{% endtab %}
{% tab title='BJ_11403.py' %}

```py
N = int(input())
G = [input().split() for _ in range(N)]

for i in range(N):
  for j in range(N):
    for k in range(N):
      if G[j][i] == '1' and G[i][k] == '1':
        G[j][k] = '1'

for i in range(N):
  print(' '.join(G[i]))
```

{% endtab %}
{% endtabs %}

* [Level 10 : 케빈 베이컨의 6단계 법칙](https://www.acmicpc.net/problem/1389)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/floyd/BJ_1389.md/)

{% tabs %}
{% tab title='BJ_1389.md' %}

> Question

* In the first line, the person with the smallest number of Kevin Bacon is printed out among BOJ users
* If there are multiple such people, print out the person with the smallest number

```txt
Input:
5 5
1 3
1 4
4 5
4 3
3 2

Output: 3
```

{% endtab %}
{% tab title='BJ_1389.py' %}

```py
V, E = map(int, input().split())
G = [[float('inf')] * V for _ in range(V)]
for i in range(V):
  G[i][i] = 0
for _ in range(E):
  u, v = map(int, input().split())
  G[u - 1][v - 1] = 1
  G[v - 1][u - 1] = 1

for i in range(V):
  for j in range(V):
    for k in range(V):
      if G[j][i] + G[i][k] < G[j][k]:
        G[j][k] = G[j][i] + G[i][k]
bacon_scores = [sum(li) for li in G]
print(bacon_scores.index(min(bacon_scores)) + 1)
```

{% endtab %}
{% endtabs %}

* [Level 12 : 서강그라운드](https://www.acmicpc.net/problem/14938)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/floyd/BJ_14938.md/)

{% tabs %}
{% tab title='BJ_14938.md' %}

> Question

* Given weighted graph
* Find maximum points you can get when you can take all points within distance M

```txt
Input:
5 5 4
5 7 8 2 3
1 4 5
5 2 4
3 2 3
1 2 3

Output: 23
```

{% endtab %}
{% tab title='BJ_14938.py' %}

```py
n, m, r = map(int, input().split())
item = list(map(int, input().split()))
inf = 10**9
A = [[inf] * n for _ in range(n)]
for _ in range(r):
  a, b, c = map(int, input().split())
  A[a - 1][b - 1] = A[b - 1][a - 1] = c

ans = 0

for k in range(n):
  A[k][k] = 0
  for i in range(n):
    for j in range(n):
      A[i][j] = min(A[i][j], A[i][k] + A[k][j])

for y in range(n):
  s = 0
  for x in range(n):
    if A[y][x] <= m:
      s += item[x]
  ans = max(ans, s)

print(ans)
```

{% endtab %}
{% endtabs %}

* [Level 12 : 키 순서](https://www.acmicpc.net/problem/2458)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/floyd/BJ_2458.md/)

{% tabs %}
{% tab title='BJ_2458.md' %}

> Question

* Given m comparison result (u > v) for n people find number of people who can distinguish one's rank

```txt
Input:
6 6
1 5
3 4
5 4
4 2
4 6
5 2

Output: 1  # 4 knows rank
```

{% endtab %}
{% tab title='BJ_2458.py' %}

```py
n, m = map(int, input().split())
G = [[0] * n for _ in range(n)]
for _ in range(m):
  u, v = map(int, input().split())
  G[u - 1][v - 1] = 1
  G[v - 1][u - 1] = -1
for k in range(n):
  for i in range(n):
    for j in range(n):
      G[i][j] = G[k][j] if G[i][k] == G[k][j] != 0 else G[i][j]
print(sum(1 for li in G if li.count(0) == 1))
```

{% endtab %}
{% endtabs %}

* [Level 13 : 저울](https://www.acmicpc.net/problem/10159)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/floyd/BJ_10159.md/)

{% tabs %}
{% tab title='BJ_10026.md' %}

> Question

* Given list of match results (a won b)
* Determine the number of match needed to find exact rank for each player

```txt
Input:
6
5
1 2
2 3
3 4
5 4
6 5

Output:
2
2
2
0
3
3
```

{% endtab %}
{% tab title='BJ_10026.py' %}

```py
INF = 1E9

n = int(input())
m = int(input())
G = [[INF] * n for _ in range(n)]
for i in range(n):
  G[i][i] = 0

for _ in range(m):
  a, b = map(int, input().split())
  G[b - 1][a - 1] = 1

for k in range(n):
  for i in range(n):
    for j in range(n):
      G[i][j] = min(G[i][j], G[i][k] + G[k][j])

result = []
for i in range(n):
  cnt = 0
  for j in range(n):
    if G[j][i] == INF and G[i][j] == INF:
      cnt += 1
  result.append(cnt)

print(*result, sep="\n")
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 2 : Evaluate Division](https://leetcode.com/problems/evaluate-division)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/floyd/LC_399.md/)

{% tabs %}
{% tab title='LC_399.md' %}

> Question

* Given an array of variable pairs equations and an array of real numbers values
  * equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]
* return answer to queries, where querie = [C, D] represents where you must find the answer for C / D = ?

```txt
Input: equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]
```

{% endtab %}
{% tab title='LC_399.py' %}

```py
# Time : O(V^3)
def calcEquation(self, equations : List[List[str]], values, queries) -> List[float]:
  quot = collections.defaultdict(dict)  # A/B=k is an edge A->B with weight k
  for (num, den), val in zip(equations, values):
    quot[num][num] = quot[den][den] = 1.0
    quot[num][den] = val
    quot[den][num] = 1 / val
  for k in quot:
    for i in quot[k]:
      for j in quot[k]:
        quot[i][j] = quot[i][k] * quot[k][j]
  return [quot[num].get(den, -1.0) for num, den in queries]
```

{% endtab %}
{% endtabs %}
