> baekjoon

* [Level 11 : 최단경로](https://www.acmicpc.net/problem/1753)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/dijkstra/BJ_1753.md/)

{% tabs %}
{% tab title='BJ_1753.md' %}

> Question

* Given a directed graph, Print the shortest path from a given starting point to all other vertices

```txt
Input:
5 6
1
5 1 1
1 2 2
1 3 3
2 3 4
2 4 5
3 4 6

Output:
0
2
3
7
INF
```

{% endtab %}
{% tab title='BJ_1753.py' %}

```py
from heapq import heappush, heappop
def dijkstra(G, start):
  dp = [0 if v == start else float('inf') for v in range(len(G))]

  heap = [(0, start)]
  while heap:
    w, n = heappop(heap)
    for n_n, wei in G[n]:
      n_w = wei + w
      if n_w < dp[n_n]:
        dp[n_n] = n_w
        heappush(heap, [n_w, n_n])
  return dp
v, e = map(int, input().split())
k = int(input())
G = [[] for _ in range(v + 1)]
for i in range(e):
  u, v, w = map(int, input().split())
  G[u].append([v, w])
for i in dijkstra(G, k)[1:]:
  print(i if i != float('inf') else "INF")
```

{% endtab %}
{% endtabs %}

* [Level 11 : 최소비용 구하기](https://www.acmicpc.net/problem/1916)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/dijkstra/BJ_1916.md/)

{% tabs %}
{% tab title='BJ_1916.md' %}

> Question

* There are prices of M buses that depart from one city and arrive in another
* Print out the minimum cost to get from A to B city

```txt
Input:
5
8
1 2 2
1 3 3
1 4 1
1 5 10
2 4 2
3 4 1
3 5 1
4 5 3
1 5

Output: 4
```

{% endtab %}
{% tab title='BJ_1916.py' %}

```py
import sys
from heapq import heappush, heappop

input = sys.stdin.readline

v, e = int(input()), int(input())
G = [[] for _ in range(v + 5)]
for _ in range(e):
  u, v, w = map(int, input().split())
  G[u].append((w, v))
s, e = map(int, input().split())
pq = [(0, s)]
dist = [0 if i == s else 1 << 30 for i in range(v + 5)]
while len(pq):
  w, u = heappop(pq)
  if w > dist[u]:
    continue
  for d, v in G[u]:
    if dist[v] > d + w:
      dist[v] = d + w
      heappush(pq, (d + w, v))
print(dist[e])
```

{% endtab %}
{% endtabs %}

* [Level 12 : 특정한 최단 경로](https://www.acmicpc.net/problem/1504)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/dijkstra/BJ_1504.md/)

{% tabs %}
{% tab title='BJ_1504.md' %}

> Question

* Print the shortest path through two vertices

```txt
Input:
4 6
1 2 3
2 3 3
3 4 1
1 3 5
2 4 5
1 4 4
2 3

Output: 7
```

{% endtab %}
{% tab title='BJ_1504.py' %}

```py
from heapq import heappush, heappop
def dijkstra(G, start):
  dp = [0 if v == start else float('inf') for v in range(len(G))]

  heap = [(0, start)]
  while heap:
    w, n = heappop(heap)
    for n_n, wei in G[n]:
      n_w = wei + w
      if n_w < dp[n_n]:
        dp[n_n] = n_w
        heappush(heap, [n_w, n_n])

  return dp
n, m = map(int, input().split())
G = [[] for _ in range(n)]
for _ in range(m):
  a, b, c = map(int, input().split())
  G[a-1].append([b-1, c])
  G[b-1].append([a-1, c])
x, y = map(int, input().split())
path1 = dijkstra(G, 0)[x-1] + dijkstra(G, x-1)[y-1] + dijkstra(G, y-1)[n-1]
path2 = dijkstra(G, 0)[y-1] + dijkstra(G, y-1)[x-1] + dijkstra(G, x-1)[n-1]
ans = min(path1, path2)
print(ans if ans < float('inf') else "-1")
```

{% endtab %}
{% endtabs %}

* [Level 12 : 택배](https://www.acmicpc.net/problem/1719)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/dijkstra/BJ_1719.md/)

{% tabs %}
{% tab title='BJ_1719.md' %}

> Question

![BJ_1719](dijkstra/images/20210306_003755.png)

* Print route chart that the first way to move the cargo from one house to another

```txt
Input:
6 10
1 2 2
1 3 1
2 4 5
2 5 3
2 6 7
3 4 4
3 5 6
3 6 7
4 6 4
5 6 2

Output:
- 2 3 3 2 2
1 - 1 4 5 5
1 1 - 4 5 6
3 2 3 - 6 6
2 2 3 6 - 6
5 5 3 4 5 -
```

{% endtab %}
{% tab title='BJ_1719.py' %}

```py
from heapq import heappush, heappop
import sys
input = sys.stdin.readline
def dijkstra(G, start, shortests):
  heap = [(0, start)]
  dp = [0 if start == i else float('inf') for i in range(n + 1)]
  while heap:
    w, v = heappop(heap)
    for adj, nw in G[v].items():
      wei = nw + w
      if dp[adj] > wei:
        dp[adj] = wei
        heappush(heap, (wei, adj))
        shortests[adj][start] = v
  return shortests

n, m = map(int, input().split())
G = [{} for i in range(n + 1)]
shortests = [[0] * n for i in range(n)]
for i in range(m):
  u, v, w = map(int, input().split())
  G[u - 1][v - 1] = w
  G[v - 1][u - 1] = w

for i in range(n):
  dijkstra(G, i, shortests)
for i in range(n):
  for j in range(n):
    if i == j:
      print("-", end=" ")
    else:
      print(shortests[i][j] + 1, end=" ")
  print()
```

{% endtab %}
{% endtabs %}

* [Level 12 : 미로만들기](https://www.acmicpc.net/problem/2665)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/dijkstra/BJ_2665.md/)

{% tabs %}
{% tab title='BJ_2665.md' %}

> Question

![BJ_2665](dijkstra/images/20210306_000446.png)

* Find minum number of rooms to convert

```txt
Input:
8
11100110
11010010
10011010
11101100
01000111
00110001
11011000
11000111

Output: 2
```

{% endtab %}
{% tab title='BJ_2665.py' %}

```py
from heapq import heappush, heappop
from collections import defaultdict
def dijkstra(G):
  dp = defaultdict(lambda : float('inf'), {(0, 0) : 0})
  heap = [(0, 0, 0)]
  while heap:
    w, r, c = heappop(heap)
    for nr, nc in [(r + 1, c), (r, c + 1), (r - 1, c), (r, c - 1)]:
      if 0 <= nr < len(G) and 0 <= nc < len(G):
        nw = w + (0 if G[r][c] == '1' else 1)
        if nw < dp[(nr, nc)]:
          dp[(nr, nc)] = nw
          heappush(heap, (nw, nr, nc))
  return dp
N = int(input())
G = [input() for _ in range(N)]
print(dijkstra(G)[(len(G) - 1, len(G) - 1)])
```

{% endtab %}
{% endtabs %}

* [Level 13 : 최소비용 구하기 2](https://www.acmicpc.net/problem/11779)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/dijkstra/BJ_11779.md/)

{% tabs %}
{% tab title='BJ_11779.md' %}

> Question

* Print shortest path between start to goal

```txt
Input:
5
8
1 2 2
1 3 3
1 4 1
1 5 10
2 4 2
3 4 1
3 5 1
4 5 3
1 5

Output:
4
3
1 3 5
```

{% endtab %}
{% tab title='BJ_11779.py' %}

```py
import heapq

n, m = int(input()), int(input())
G = [[] for _ in range(n + 1)]
parent = [None] * (n + 1)
for _ in range(m):
  a, b, c = map(int, input().split())
  G[a].append((c, b))

start, end = map(int, input().split())
dist = [10**10 + 1] * (n + 1)
dist[start] = 0
pq = [(0, start)]
while pq:
  d, i = heapq.heappop(pq)
  if dist[i] != d:
    continue
  if i == end:
    break
  for e, j in G[i]:
    if e + d < dist[j]:
      dist[j] = e + d
      parent[j] = i
      heapq.heappush(pq, (dist[j], j))

path = [end]
while path[-1] != start:
  path.append(parent[path[-1]])
print(dist[end])
print(len(path))
print(*reversed(path))
```

{% endtab %}
{% endtabs %}

* [Level 16 : K번째 최단경로 찾기](https://www.acmicpc.net/problem/1854)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/dijkstra/BJ_1854.md/)

{% tabs %}
{% tab title='BJ_1854.md' %}

> Question

* Given number of vertices, edges and K
* Find Kth fastest path from 1 to each vertices

```txt
Input:
5 10 2
1 2 2
1 3 7
1 4 5
1 5 6
2 4 2
2 3 4
3 4 6
3 5 8
5 2 4
5 4 1

Output:
-1
10
7
5
14
```

{% endtab %}
{% tab title='BJ_1854.py' %}

```py
import heapq
import sys
input=sys.stdin.readline
n, m, k = map(int,input().split())
G = [[] for _ in range(n)]
for _ in range(m):
  i, j, d = map(int,input().split())
  G[i-1].append((j - 1, d))
D = [[] for _ in range(n)]
q = [(0, 0)]
while q:
  r, i = heapq.heappop(q)
  if len(D[i]) == k:
    continue
  D[i].append(r)
  for j, s in G[i]:
    heapq.heappush(q, (r + s, j))
for i in range(n):
  if len(D[i]) < k: print(-1)
  else: print(D[i][k-1])
```

{% endtab %}
{% endtabs %}

* [Level 16 : 거의 최단 경로](https://www.acmicpc.net/problem/5719)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/dijkstra/BJ_5719.md/)

{% tabs %}
{% tab title='BJ_5719.md' %}

> Question

* Print second minimum path without passing edges from minimum path

```txt
Input:
7 9
0 6
0 1 1
0 2 1
0 3 2
0 4 3
1 5 2
2 6 4
3 6 2
4 6 4
5 6 1
4 6
0 2
0 1 1
1 2 1
1 3 1
3 2 1
2 0 3
3 0 2
6 8
0 1
0 1 1
0 2 2
0 3 3
2 5 3
3 4 2
4 1 1
5 1 1
3 0 1
0 0

Output:
5
-1
6
```

{% endtab %}
{% tab title='BJ_5719.py' %}

```py
from sys import stdin
from heapq import *
input = stdin.readline

def dijkstra(s,d):
  v[s] = 0
  pq = [[0,s]]
  while pq:
    cost, x = heappop(pq)
    for i in range(n):
      if 0 < G[x][i] < v[i] - cost:
        v[i] = G[x][i] + cost
        p[i] = x
        heappush(pq, [G[x][i] + cost, i])
  return -1 if v[d] == 1e9 else v[d]

def r(s,d):
  pq = [[v[d], d]]
  while pq:
    cost, x = heappop(pq)
    for i in range(n):
      if G[i][x] > 0 and v[i] == cost - G[i][x]:
        G[i][x] = -1
        heappush(pq, [v[i], i])

while 1:
  n, m = map(int,input().split())
  if n == m == 0:
    break
  G, p = [[-1] * n for _ in range(n)], [-1] * n
  s, d = map(int,input().split())
  for _ in range(m):
    z, x, c = map(int, input().split())
    G[z][x] = c
  v = [1e9] * n
  t = dijkstra(s,d)
  if t == -1:
    print(-1)
  else:
    r(s, d)
    v = [1e9] * n
    print(dijkstra(s,d))
```

{% endtab %}
{% endtabs %}

* [Level 17 : peedy Escape](https://www.acmicpc.net/problem/5036)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/dijkstra/BJ_5036.md/)

{% tabs %}
{% tab title='BJ_5036.md' %}

> Question

* The police car has a maximum speed of 160 km/h
* brothers ever end up at the same point at the same time as the police car they will be caught
* brothers want to find a fixed route that ensures that they are able to leave the city no matter what route police car take
* print minimal speed in km/h required to escape or the word IMPOSSIBLE if it is impossible

```txt
Input:
3 2 1
1 2 7
2 3 8
1
2 3

Output: 74.66666667
```

> Solution

1. constuct the grid, save the hight way exits in set
1. find the shotest path from the police / car intersection to other intersections (dijkstra)
1. if the exist in the ca intersection speed = 0 && if the exist is in the police intersection speed = IMP
1. make binary search in all speeds from .00001 to INF
1. in every speed you calculate the time required to reach other intersection to knew the valid intersections at this speed
1. if there is a way with valid intersections at this speed you minmize the speed (upper = mid)
1. if else you maxmize the speed (lower = mid)
1. repeat untile(upper == lower)
1. return the lower if < INF or return IMP

{% endtab %}
{% tab title='BJ_5036.py' %}

```cpp
#include <bits/stdc++.h>
#define INF 2e9

using namespace std;

void dijkstra(int, int, double);

int N, M, E;
vector<pair<int, int>> G[101];
vector<int> escape;
int b, p;
int dist[101][2];
double t[101][2];

struct cmp {
  bool operator()(pair<int, int> a, pair<int, int> b) { return a.second > b.second; }
};

int main(void) {
  cin >> N >> M >> E;

  for (int i = 1; i <= M; i++) {
    int from, to, weight;
    cin >> from >> to >> weight;

    G[from].push_back(make_pair(to, weight));
    G[to].push_back(make_pair(from, weight));
  }

  for (int i = 1; i <= E; i++) {
    int e;
    cin >> e;
    escape.push_back(e);
  }

  cin >> b >> p;
  dijkstra(p, 0, 160.0);
  double lo = 0.0, hi = INF, min = INF;
  for (int i = 1; i <= 100; i++) {
    double mi = (lo + hi) / 2;
    dijkstra(b, 1, mi);

    bool flag = false;
    for (auto e : escape) {
      if (t[e][1] < t[e][0]) {
        flag = true;
        break;
      }
    }

    if (flag) hi = min = mi;
    else lo = mi;
  }

  printf(min == INF ? "IMPOSSIBLE\n" : "%.10lf\n", min);

  return 0;
}

void dijkstra(int v, int type, double velocity) {
  priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> PQ;

  for (int i = 1; i <= N; i++) {
    dist[i][type] = (int)INF;
    t[i][type] = INF;
  }

  dist[v][type] = t[v][type] = 0.0;
  PQ.push(make_pair(v, dist[v][type]));

  while (!PQ.empty()) {
    int cur = PQ.top().first;
    PQ.pop();

    for (auto child : G[cur]) {
      if (!type && dist[cur][type] + child.second < dist[child.first][type]) {
        dist[child.first][type] = dist[cur][type] + child.second;
        t[child.first][type] = dist[child.first][type] / velocity;
        PQ.push(make_pair(child.first, dist[child.first][type]));
      }

      if (type && dist[cur][type] + child.second < dist[child.first][type] &&
          (dist[cur][type] + child.second) / velocity < t[child.first][0]) {
        dist[child.first][type] = dist[cur][type] + child.second;
        t[child.first][type] = dist[child.first][type] / velocity;
        PQ.push(make_pair(child.first, dist[child.first][type]));
      }
    }
  }
}
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 2 : Number of Restricted Paths From First to Last Node](https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/dijkstra/LC_1786.md/)

{% tabs %}
{% tab title='LC_1786.md' %}

> Question

* Given an undirected weighted connected graph
* with a positive integer n which denotes that graph has n nodes labeled from 1 to n, and edges= [ui, vi, weighti]
* A path from node start to node end is a sequence of nodes [z0, z1, z2, ..., zk] such that z0 = start and zk = end
* there is an edge between zi and zi+1 where 0 <= i <= k-1
* The distance of a path is the sum of the weights on the edges of the path
* Let distanceToLastNode(x) denote the shortest distance of a path between node n and node x
* Restricted path is a path that also satisfies that distanceToLastNode(zi) > distanceToLastNode(zi+1) where 0 <= i <= k-1
* Return # restricted paths from node 1 to node n modulo 10 ** 9 + 7

```txt
Input: n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
Output: 3
```

{% endtab %}
{% tab title='LC_1786.py' %}

```py
class Solution:
  def countRestrictedPaths(self, n: int, edges: List[List[int]]) -> int:
    if n == 1: return 0
    graph = defaultdict(list)
    for u, v, w in edges:
      graph[u].append((w, v))
      graph[v].append((w, u))

    dist2n = [inf] * (n) + [0]
    minHeap = [(0, n)]
    while minHeap:
      d, u = heappop(minHeap)
      for w, v in graph[u]:
        if dist2n[v] > dist2n[u] + w:
          dist2n[v] = dist2n[u] + w
          heappush(minHeap, (dist2n[v], v))

    @lru_cache(None)
    def dfs(src):
      if src == n: return 1
      ans = 0
      for _, nei in graph[src]:
        if dist2n[src] > dist2n[nei]:
          ans = (ans + dfs(nei)) % 1000000007
      return ans

    return dfs(1)
```

{% endtab %}
{% endtabs %}
