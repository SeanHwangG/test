> baekjoon

* [Level 18 : Cactus? Not cactus?](https://www.acmicpc.net/problem/10891)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/bcc/BJ_10891.md/)

{% tabs %}
{% tab title='BJ_10891.md' %}

> Question

* Print if a graph is catus where for each node there has <= 1 cycle

```txt
Input:
4 4
1 2
2 3
3 1
3 4

Output: Cactus

Input:
5 6
1 2
2 3
3 1
3 4
4 5
5 3

Output: Not cactus
```

{% endtab %}
{% tab title='BJ_10891.py' %}

```cpp
#include <bits/stdc++.h>
using namespace std;

int N, M, lev[100005];
vector<int> v[100005];
bool cactus;

int dfs(int x, int p) {
  int cnt = 0;
  int ret = lev[x] = lev[p] + 1;
  for (int it : v[x]) if(it != p) {
    int res = (lev[it] ? lev[it] : dfs(it, x));
    if(res <= lev[x]) cnt++;
    ret = min(ret, res);
  }
  if (cnt > 1) cactus = 1;
  return ret;
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> N >> M;
  for(int i=0, x, y; i<M; i++) {
    cin >> x >> y;
    v[x].push_back(y), v[y].push_back(x);
  }
  dfs(1, 0);
  if(cactus) cout << "Not cactus\n";
  else cout << "Cactus\n";
}
```

{% endtab %}
{% endtabs %}

* [Level 24 : uathlon](https://www.acmicpc.net/problem/15768)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/bcc/BJ_15768.md/)

{% tabs %}
{% tab title='BJ_15768.md' %}

> Question

* Given undirected graph find number (s, c, f) s.t. there is a simple path from s -> c -> f

```txt
Input:
4 3
1 2
2 3
3 4

Output: 8
```

{% endtab %}
{% tab title='BJ_15768.cpp' %}

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

vector <ll> G[101010], V;
ll N[101010], L[101010], S[101010];
ll n, dn, c1, c2, a;

ll dfs(ll u, ll p) {
  ll t, x, y, z, s = S[u] = 1;

  N[u] = L[u] = ++dn;
  V.push_back(u);

  for (ll &v: G[u])
    if(v != p) {
      if (!N[v]) {
        t = dfs(v, u);
        s += t;
        if (!p || L[v] >= N[u]){
          S[u] += t;
          for (x = y = z = t = 0; t != v; V.pop_back()){
            t = V.back();
            x++;
            y += S[t];
            z += S[t] * S[t];
          }
          a -= (y * y + z) * x;
          c2 += x; c1 += (y + y + 1) * x;
        }
        else L[u] = min(L[u], L[v]);
      }
      else {
        L[u] = min(L[u], N[v]);
      }
    }

  return s;
}

int main() {
  ios::sync_with_stdio(0); cin.tie(0);
  ll m, t;  cin >> n >> m;

  for (; m --; ) {
    ll u, v; cin >> u >> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }

  for (int i = 1; i <= n; i ++){
    if (!N[i]) {
      V.clear(); c1 = 0; c2 = 0;
      t = dfs(i, 0);
      a += t * (t - 1) * (t - 2) - c2 * t * t + c1 * t;
    }
  }

  cout << a << "\n";

  return 0;
}
```

{% endtab %}
{% endtabs %}
