> leetcode

* [Level 2 : Open the Lock](https://leetcode.com/problems/open-the-lock)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/bfs-bidirection/LC_752.md/)

{% tabs %}
{% tab title='LC_752.md' %}

> Question

* Given lock with 4 circular wheels. Each wheel has 10 slots: '0-9'
* The wheels can rotate freely and wrap around, each move consists of turning one wheel one slot. ([ex] '9'<->'0')
* Lock initially starts at '0000', a string representing the state of the 4 wheels.
* Given deadends lists, meaning if lock displays these, wheels of lock will stop turning and you will be unable to open it
* Given password, Return min total # turns required to open lock, or -1 if it's impossible

```txt
Input: deadends = ["0201","0101","0102","1212","2002"], target = "0202"
Output: 6
```

{% endtab %}
{% tab title='LC_752.py' %}

```py
def openLock(self, deadends, target):
  dead = set(deadends)
  if "0000" in dead: return -1

  q1, q2 = deque([(0, "0000")]), deque([(0, target)])
  visited1, visited2 = {"0000": 0}, {target: 0}
  limit, ans = float("inf"), float("inf")

  while q1:
    if len(q1) > len(q2):
      q1, q2 = q2, q1
      visited1, visited2 = visited2, visited1

    steps, code = q1.popleft()
    if steps + q2[0][0] > limit: return ans

    if code in visited2:
      limit = steps + q2[0][0]
      ans = min(visited1[code] + visited2[code], ans)

    for i in range(4):
      d = int(code[i])
      for k in (d - 1) % 10, (d + 1) % 10:
        cand = code[:i] + str(k) + code[i+1:]
        if cand not in visited1 and cand not in dead:
          visited1[cand] = steps + 1
          q1.append((steps+1, cand))
  return -1
```

{% endtab %}
{% endtabs %}

* [Level 3 : Word Ladder II](https://leetcode.com/problems/word-ladder-ii)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/graph/bfs-bidirection/LC_126.md/)

{% tabs %}
{% tab title='LC_126.md' %}

> Question

* Transformation sequence from word begin to word end using dictionary wordList is sequence of words begin, s1, ..., sk st:
  * Every adjacent pair of words differs by a single letter.
  * Every si for 1 <= i <= k is in wordList. Note that begin does not need to be in wordList.
  * sk == end
* Given two words, begin and end, and dictionary wordList, return all shortest transformation sequences from begin to end
* Each sequence should be returned as a list of the words [begin, s1, s2, ..., sk].

```txt
Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
Output: [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
```

{% endtab %}
{% tab title='LC_126.py' %}

```py
def findLadders(self, begin: str, end: str, words: List[str]) -> List[List[str]]:
  def construct_tree(begin, end):
    if begin == end:
      return [[begin]]
    return [[begin] + path for nei in tree[begin] for path in construct_tree(nei, end)]
  def add_path(word, nei, forward):
    if forward:
      tree[word].append(nei)
    else:
      tree[nei].append(word)
    return nei
  words, front, back, forward, tree = set(words), set([begin]), set([end]), True, defaultdict(list)
  if end not in words:
    return []
  while front:
    words -= front
    front = set(add_path(w, w[:i] + ch + w[i + 1:], forward) for w in front for i in range(len(w)) for ch in ascii_lowercase
      if w[:i] + ch + w[i + 1:] in words)
    if front & back:
      break
    if len(front) > len(back):
      front, back, forward = back, front, not forward
  return construct_tree(begin, end)
```

{% endtab %}
{% endtabs %}
