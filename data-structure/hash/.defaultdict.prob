> baekjoon

* [Level 13 : 두 배열의 합](https://www.acmicpc.net/problem/2143)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/hash/defaultdict/BJ_2143.md/)

{% tabs %}
{% tab title='BJ_2143.md' %}

> Question

* Given two range print the number of slice that sum of to T

```txt
Input:
5
4
1 3 1 2
3
1 3 2

Output: 7  # 1, 1 2 / 1 2, 1 / 2, 3...
```

{% endtab %}
{% tab title='BJ_2143.py' %}

```py
from collections import defaultdict
t, n, a = int(input()), int(input()), list(map(int, input().split()))
m, b = int(input()), list(map(int, input().split()))
dic, ans = defaultdict(int), 0
for i in range(n):
  for j in range(i, n, 1):
    dic[sum(a[i:j + 1])] += 1

for i in range(m):
  for j in range(i, m, 1):
    ans += dic[t - sum(b[i:j + 1])]
print(ans)
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 3 : Maximum Frequency Stack](https://leetcode.com/problems/maximum-frequency-stack)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/hash/defaultdict/LC_895.md/)

{% tabs %}
{% tab title='LC_895.md' %}

> Question

* Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.
* Implement the FreqStack class:
  * FreqStack() constructs an empty frequency stack.
  * void push(int val) pushes an integer val onto the top of the stack.
  * int pop() removes and returns the most frequent element in the stack.
  * If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.

```txt
Input
["FreqStack", "push", "push", "push", "push", "push", "push", "pop", "pop", "pop", "pop"]
[[], [5], [7], [5], [7], [4], [5], [], [], [], []]

Output
[null, null, null, null, null, null, null, 5, 7, 5, 4]
```

{% endtab %}
{% tab title='LC_895.py' %}

```py
def __init__(self):
  self.freq = collections.Counter()
  self.m = collections.defaultdict(list)
  self.maxf = 0

def push(self, x):
  freq, m = self.freq, self.m
  freq[x] += 1
  self.maxf = max(self.maxf, freq[x])
  m[freq[x]].append(x)

def pop(self):
  freq, m, maxf = self.freq, self.m, self.maxf
  x = m[maxf].pop()
  if not m[maxf]:
    self.maxf = maxf - 1
  freq[x] -= 1
  return x
```

{% endtab %}
{% endtabs %}
