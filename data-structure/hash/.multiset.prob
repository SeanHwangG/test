> leetcode

* [Level 1 : Valid Anagram](https://leetcode.com/problems/valid-anagram)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/hash/multiset/LC_242.md/)

{% tabs %}
{% tab title='LC_242.md' %}

> Question

* Given two strings s and t, return true if t is an anagram of s, and false otherwise

```txt
Input: s = "anagram", t = "nagaram"
Output: true
```

{% endtab %}
{% tab title='LC_242.cpp' %}

```cpp
bool isAnagram(string s, string t) {
  return unordered_multiset<char>(begin(s), end(s)) == unordered_multiset<char>(begin(t), end(t));
}
```

{% endtab %}
{% endtabs %}

* [Level 3 : Sliding Window Median](https://leetcode.com/problems/sliding-window-median)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/hash/multiset/LC_480.md/)

{% tabs %}
{% tab title='LC_480.md' %}

> Question

* Given an integer array nums and an integer k
* There is a sliding window of size k which is moving from the very left of the array to the very right
* Only see the k numbers in the window, each time the sliding window moves right by one position.
* Return median array for each window in the original array (error within 10^-5 will be accepted)

```txt
Input: nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3
Output: [1.00000, -1.00000, -1.00000, 3.00000, 5.00000, 6.00000]
```

{% endtab %}
{% tab title='LC_480.cpp' %}

```cpp
vector<double> medianSlidingWindow(vector<int>& nums, int k) {
  multiset<int> window(nums.begin(), nums.begin() + k);
  auto mid = next(window.begin(), k / 2);
  vector<double> medians;
  for (int i = k;; i++) {
    // Push the current median
    medians.push_back((double(*mid) + *prev(mid, 1 - k % 2)) / 2);

    if (i == nums.size())
      return medians;

    // Insert nums[i]
    window.insert(nums[i]);
    if (nums[i] < *mid) mid--;

    // Erase nums[i - k]
    if (nums[i - k] <= *mid) mid++;
    window.erase(window.lower_bound(nums[i - k]));
  }
}
```

{% endtab %}
{% tab title='LC_480.py' %}

```py
from sortedcontainers import SortedList
class Solution:
  def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
    window = SortedList(nums[:k-1])
    median = []

    for a, b in zip(nums, nums[k-1:]):
      window.add(b)
      median.append((window[k // 2] + window[~k // 2]) / 2)
      window.remove(a)

    return median
```

{% endtab %}
{% endtabs %}
