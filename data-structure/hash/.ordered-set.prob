> baekjoon

* [Level 6 : 중복 빼고 정렬하기](https://www.acmicpc.net/problem/10867)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/hash/ordered-set/BJ_10867.md/)

{% tabs %}
{% tab title='BJ_10867.md' %}

> Question

* Print in unique element in ascending order

```txt
Input:
10
1 4 2 3 1 4 2 3 1 2

Output: 1 2 3 4
```

{% endtab %}
{% tab title='BJ_10867.cpp' %}

```cpp
#include <iostream>
#include <set>

using namespace std;

int main() {
  int n, a;
  cin >> n;
  set<int> S;
  while (n--) {
    cin >> a;
    S.insert(a);
  }
  for (auto c : S) cout << c << " ";
}
```

{% endtab %}
{% tab title='BJ_10867.py' %}

```py
input()
print(*sorted(set(map(int, input().split()))))
```

{% endtab %}
{% endtabs %}

* [Level 6 : 회사에 있는 사람](https://www.acmicpc.net/problem/7785)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/hash/ordered-set/BJ_7785.md/)

{% tabs %}
{% tab title='BJ_7785.md' %}

> Question

* n access records given, each person's name, and either "enter" or "leave". "enter"
* Print all people in office

```txt
Input:
4
Baha enter
Askar enter
Baha leave
Artem enter

Output:
Askar
Artem
```

{% endtab %}
{% tab title='BJ_7785.cpp' %}

```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
  int n; cin >> n;

  set<string> st;
  while (n--) {
    string nm, a; cin >> nm >> a;
    if (a[0] == 'e')
      st.insert(nm);
    else
      st.erase(nm);
  }

  for (auto it = st.rbegin(); it != st.rend(); it++)
    cout << *it << '\n';

  return 0;
}
```

{% endtab %}
{% tab title='BJ_7785.py' %}

```py
import sys
input = sys.stdin.readline
people = set()
for _ in range(int(input())):
  name, act = input().split()
  if act == "enter":
    people.add(name)
  else:
    people.remove(name)
print("\n".join(sorted(people, reverse=True)))
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 2 : Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/hash/ordered-set/LC_220.md/)

{% tabs %}
{% tab title='LC_220.md' %}

> Question

* Given an int array nums and two integers k and t, return if there are two distinct indices i and j in array
  * such that abs(nums[i] - nums[j]) <= t and abs(i - j) <= k

```txt
Input: nums = [1,2,3,1], k = 3, t = 0
Output: true
```

{% endtab %}
{% tab title='LC_220.cpp' %}

```cpp
bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
  set<long long> window;
  for (int i = 0; i < nums.size(); ++i) {
    if (i > k && i - k - 1 < nums.size()) window.erase(nums[i - k - 1]);
    auto it = window.lower_bound((long long)nums[i] - t);
    if (it != window.cend() && *it - nums[i] <= t) return true;
    window.insert(nums[i]);
  }
  return false;
}
```

{% endtab %}
{% tab title='LC_220.py' %}

```py
from sortedcontainers import SortedList

def containsNearbyAlmostDuplicate(self, nums, k, t):
    slist = SortedList()
    for i, n in enumerate(nums):
      if i > k: SList.remove(nums[i - k - 1])
      pos1 = SortedList.bisect_left(slist, n - t)
      pos2 = SortedList.bisect_right(slist, n + t)
      if pos1 != pos2 and pos1 != len(slist): return True
      slist.add(n)

    return False
```

{% endtab %}
{% endtabs %}
