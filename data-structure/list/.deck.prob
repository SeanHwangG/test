> baekjoon

* [Level 7 : 회전하는 큐](https://www.acmicpc.net/problem/1021)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/deck/BJ_1021.md/)

{% tabs %}
{% tab title='BJ_1021.md' %}

> Question

* Given elements in deck, 1, ..., N
* find minimum number of operator to extract all elements

```txt
Input:
10 3
1 2 3

Output: 0
```

{% endtab %}
{% tab title='BJ_1021.cpp' %}

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
  int N, M, count=0; cin >> N >> M;
  deque<int> dq;
  for (int i = 0; i < N; i++) dq.push_back(i + 1);
  while (M--) {
    int temp; cin >> temp;
    for (int i = 0; i < N; i++) {
      if (dq[i] == temp) {
        rotate(dq.begin(), dq.begin() + i, dq.end());
        count += min(i, N - i);
        break;
      }
    }
    dq.pop_front();
    N--;
  }
  cout << count;
}
```

{% endtab %}
{% tab title='BJ_1021.py' %}

```py
from collections import deque
n, m =map(int,input().split())
l = list(map(int,input().split()))
Q = deque(range(1,n+1))
ans = 0
for i in l:
  a = Q.index(i)
  b = n-a
  if a<b: ans+=a; Q.rotate(-a); Q.popleft()
  else: ans+=b; Q.rotate(b); Q.popleft()
  n-=1
print(ans)
```

{% endtab %}
{% tab title='BJ_1021.v' %}

```v
module main;
    logic clk, reset, push_front, push_back, pop_front, pop_back;
    logic signed[17:0] din, dout_front, dout_back;
    logic[13:0] size;

    deque deque(.clk, .reset, .push_front, .push_back, .pop_front, .pop_back, .din, .dout_front, .dout_back, .size);

    initial begin
        integer code, n, x;
        string cmd;

        clk = 0;
        push_front = 0;
        push_back = 0;
        pop_front = 0;
        pop_back = 0;
        #1 reset = 1;
        #1 reset = 0;

        for (code = $fscanf(32'h8000_0000, "%d", n); n>0; n--)
        begin
            code = $fscanf(32'h8000_0000, "%s", cmd);
            if (cmd == "push_front" || cmd == "push_back") code = $fscanf(32'h8000_0000, "%d", din);
            if (cmd == "pop_front" || cmd == "front") $display("%0d", dout_front);
            if (cmd == "pop_back" || cmd == "back") $display("%0d", dout_back);
            if (cmd == "size") $display("%0d", size);
            if (cmd == "empty") $display("%0d", size == 0);

            push_front = cmd == "push_front";
            push_back = cmd == "push_back";
            pop_front = cmd == "pop_front";
            pop_back = cmd == "pop_back";
            #1 clk = 1;
            #1 clk = 0;
        end
        $finish;
    end
endmodule

module deque(
    input logic clk, reset,

    input logic push_front, push_back, pop_front, pop_back,
    input logic signed[17:0] din,
    output logic signed[17:0] dout_front, dout_back,
    output logic[13:0] size
);
    logic signed[17:0] mem[0:16383];
    logic[13:0] index_front, index_back;

    assign size = index_front - index_back + 1;
    assign dout_front = size == 0 ? '1 : mem[index_front];
    assign dout_back = size == 0 ? '1 : mem[index_back];

    always_ff @(posedge clk, posedge reset)
    begin
        if (reset) begin
            index_front = 0;
            index_back = 1;
        end
        else begin
            if (push_front) mem[++index_front] = din;
            if (push_back) mem[--index_back] = din;
            if (pop_front && size>0) --index_front;
            if (pop_back && size>0) ++index_back;
        end
    end
endmodule
```

{% endtab %}
{% endtabs %}

* [Level 7 : 덱](https://www.acmicpc.net/problem/10866)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/deck/BJ_10866.md/)

{% tabs %}
{% tab title='BJ_10866.md' %}

> Question

* push_front X: Put the integer X in front of the deck
* push_back X: Put the integer X behind the deck
* pop_front: subtracts the number at the front of the deck and outputs it. If there are no integers in the deck, print -1
* pop_back: subtracts the number at the end of the deck and outputs it. If there are no integers in the deck, print -1
* size: print the number of integers in the deck
* empty: If the deck is empty, print 1 or 0
* front: Outputs an integer at the front of the deck. If there are no integers in the deck, print -1
* back: Outputs an integer at the back of the deck. If there are no integers in the deck, print -1

```txt
Input:
15
push_back 1
push_front 2
front
back
size
empty
pop_front
pop_back
pop_front
size
empty
pop_back
push_front 3
empty
front

Output:
2
1
2
0
2
1
-1
0
1
-1
0
3
```

{% endtab %}
{% tab title='BJ_10866.cpp' %}

```cpp
#include <bits/stdc++.h>
using namespace std;
deque<int> dq;
int n;

int main() {
  ios_base::sync_with_stdio(0);
  string t; int d;
  cin >> n;
  for(;n--;){
    cin >> t;
    if(t == "push_back")  cin >> d, dq.push_back(d);
    if(t == "push_front") cin >> d, dq.push_front(d);
    if(t == "size")  cout << dq.size() << '\n';
    if(t == "empty") cout << dq.empty() << '\n';
    if(t == "front") cout << (dq.size() ? dq.front() : -1) << '\n';
    if(t == "back")  cout << (dq.size() ? dq.back() : -1) << '\n';
    if(t == "pop_back"){
      cout << (dq.size() ? dq.back() : -1) << '\n';
      if(dq.size()) dq.pop_back();
    }
    if(t == "pop_front"){
      cout << (dq.size() ? dq.front() : -1) << '\n';
      if(dq.size()) dq.pop_front();
    }
  }
  return 0;
}
```

{% endtab %}
{% tab title='BJ_10866.py' %}

```py
import sys
from collections import deque
input = sys.stdin.readline
N = int(input())
dq = deque()
for i in range(N):
  cmd = list(input().split())
  if cmd[0] == 'push_front':
    dq.appendleft(cmd[1])
  elif cmd[0] == 'push_back':
    dq.append(cmd[1])
  elif cmd[0] == 'pop_front':
    print("-1" if len(dq) == 0 else dq.popleft())
  elif cmd[0] == 'pop_back':
    print("-1" if len(dq) == 0 else dq.pop())
  elif cmd[0] == 'front':
    print("-1" if len(dq) == 0 else dq[0])
  elif cmd[0] == 'back':
    print("-1" if len(dq) == 0 else dq[-1])
  elif cmd[0] == 'size':
    print(len(dq))
  elif cmd[0] == 'empty':
    print(1 if len(dq) == 0 else 0 )
```

{% endtab %}
{% endtabs %}

* [Level 16 : 최솟값 찾기](https://www.acmicpc.net/problem/11003)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/deck/BJ_11003.md/)

{% tabs %}
{% tab title='BJ_11003.md' %}

> Question

* Given list, find minimum of $$ A_{i + L + 1} $$ ~ $$ A_i $$ at each index

```txt
Input:
12 3
1 5 2 3 6 2 3 7 3 5 2 6

Output:
1 1 1 2 2 2 2 2 3 3 2 2
```

{% endtab %}
{% tab title='BJ_11003.py' %}

```py
from collections import deque
n, l = map(int,input().split())
li = [*map(int,input().split())]
d = deque()
for i in range(n):
  if d and d[0]<i-l+1:
    d.popleft()
  while d and li[d[-1]] >= li[i]:
    d.pop()
  d.append(i)
  print(li[d[0]])
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 2 : Design Front Middle Back Queue](https://leetcode.com/problems/design-front-middle-back-queue)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/deck/LC_1670.md/)

{% tabs %}
{% tab title='LC_1670.md' %}

> Question

* Design a queue that supports push and pop operations in the front, middle, and back.
* Implement the FrontMiddleBack class:
  * FrontMiddleBack() Initializes the queue
  * void pushFront(int val) Adds val to the front of the queue
  * void pushMiddle(int val) Adds val to the middle of the queue (performed on the frontmost middle position choice)
  * void pushBack(int val) Adds val to the back of the queue
  * int popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1
  * int popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1
  * int popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1

```txt
Input:
["FrontMiddleBackQueue", "pushFront", "pushBack", "pushMiddle", "pushMiddle", "popFront", "popMiddle", "popMiddle", \
"popBack", "popFront"]
[[], [1], [2], [3], [4], [], [], [], [], []]

Output:
[null, null, null, null, null, 1, 3, 4, 2, -1]
```

{% endtab %}
{% tab title='LC_1670.py' %}

```py
class FrontMiddleBackQueue(object):
  def __init__(self):
    self.A, self.B = collections.deque(), collections.deque()

  def pushFront(self, val):
    self.A.appendleft(val)
    self.balance()

  def pushMiddle(self, val):
    if len(self.A) > len(self.B):
      self.B.appendleft(self.A.pop())
    self.A.append(val)

  def pushBack(self, val):
    self.B.append(val)
    self.balance()

  def popFront(self):
    val = self.A.popleft() if self.A else -1
    self.balance()
    return val

  def popMiddle(self):
    val = (self.A or [-1]).pop()
    self.balance()
    return val

  def popBack(self):
    val = (self.B or self.A or [-1]).pop()
    self.balance()
    return val

  # keep A.size() >= B.size()
  def balance(self):
    if len(self.A) > len(self.B) + 1:
      self.B.appendleft(self.A.pop())
    if len(self.A) < len(self.B):
      self.A.append(self.B.popleft())
```

{% endtab %}
{% endtabs %}
