> kattis

* [Level 1.6 : Ptice](https://open.kattis.com/problems/ptice)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/linkedlist/KT_ptice.md/)

{% tabs %}
{% tab title='KT_Ptice.md' %}

> Question

* Repeat ABC, BABC, CCAABB
* find whose sequence contains the most correct answers

```txt
Input:
5
BAACC

Output:
3
Bruno
```

{% endtab %}
{% tab title='KT_Ptice.py' %}

```py
length = int(input())
li = list(input())
a = ['A', 'B', 'C']
b = ['B', 'A','B', 'C']
g = ['C', 'C', 'A','A','B','B']
scores = [0, 0 , 0]
for i in range(length):
  if li[i] == a[i % 3]:
    scores[0] += 1
  if li[i] == b[i % 4]:
    scores[1] += 1
  if li[i] == g[i % 6]:
    scores[2] += 1

print(max(scores))
if max(scores) == scores[0]:
  print('Adrian')
if max(scores) == scores[1]:
  print('Bruno')
if max(scores) == scores[2]:
  print('Goran')
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 1 : Reverse Linked List](https://leetcode.com/problems/reverse-linked-list)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/linkedlist/LC_206.md/)

{% tabs %}
{% tab title='LC_206.md' %}

> Question

* Reverse linked list

```txt
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```

{% endtab %}
{% tab title='LC_206.js' %}

```js
var reverseList = function(head) {
  let [prev, current] = [null, head]
  while (current) {
    [current.next, prev, current] = [prev, current, current.next]
  }
  return prev
}
```

{% endtab %}
{% tab title='LC_206.py' %}

```py
def reverseList(self, head: ListNode) -> ListNode:
  if head == None:
    return None
  prev = None
  while head.next != None:
    nxt = head.next
    head.next = prev
    prev, head = head, nxt
  head.next = prev
  return head
```

{% endtab %}
{% endtabs %}

* [Level 1 : Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/linkedlist/LC_21.md/)

{% tabs %}
{% tab title='LC_21.md' %}

> Question

* Merge two linked lists

```txt
Input: l1 = [1,2,4], l2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

{% endtab %}
{% tab title='LC_21.cpp' %}

```cpp
ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
  ListNode dummy(INT_MIN);
  ListNode *tail = &dummy;
  while (l1 && l2) {
    if (l1->val < l2->val) {
      tail->next = l1;
      l1 = l1->next;
    } else {
      tail->next = l2;
      l2 = l2->next;
    }
    tail = tail->next;
  }

  tail->next = l1 ? l1 : l2;
  return dummy.next;
}

```

{% endtab %}
{% tab title='LC_21.py' %}

```py
def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
  dummy = cur = ListNode(0)
  while l1 and l2:
    if l1.val < l2.val:
      cur.next = l1
      l1 = l1.next
    else:
      cur.next = l2
      l2 = l2.next
    cur = cur.next
  cur.next = l1 or l2
  return dummy.next
```

{% endtab %}
{% endtabs %}

* [Level 2 : Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/linkedlist/LC_138.md/)

{% tabs %}
{% tab title='LC_138.md' %}

> Question

* linked list of length n is given st each node contains an random pointer, which could point to any node in list, or null
* Construct a deep copy of the list

```txt
Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]
```

{% endtab %}
{% tab title='LC_138.py' %}

```py
class Solution:
  def copyRandomList(self, head: 'Node') -> 'Node':
    # create new nodes
    node = head
    while node:
      node.random, node = Node(node.val, node.random, None), node.next
    # populate random field of the new node
    node = head
    while node:
      node.random.random, node = node.random.next.random if node.random.next else None, node.next
    # restore original list and build new list
    head_copy, node = head.random if head else None, head
    while node:
      node.random.next, node.random, node = node.next.random if node.next else None, node.random.next, node.next
    return head_copy
```

{% endtab %}
{% endtabs %}

* [Level 2 : Add Two Numbers](https://leetcode.com/problems/add-two-numbers)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/linkedlist/LC_2.md/)

{% tabs %}
{% tab title='LC_2.md' %}

> Question

* Add two linked list number

```txt
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
```

{% endtab %}
{% tab title='LC_2.py' %}

```py
def addTwoNumbers(self, l1, l2):
  carry = 0
  res = n = ListNode(0)
  while l1 or l2 or carry:
    if l1:
      carry += l1.val
      l1 = l1.next
    if l2:
      carry += l2.val
      l2 = l2.next
    carry, val = divmod(carry, 10)
    n.next = n = ListNode(val)
  return res.next
```

{% endtab %}
{% endtabs %}

* [Level 2 : Rotate List](https://leetcode.com/problems/rotate-list)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/linkedlist/LC_61.md/)

{% tabs %}
{% tab title='LC_61.md' %}

> Question

* Given the head of a linked list, rotate the list to the right by k places

```txt
Input: head = [1,2,3,4,5], k = 2
Output: [4,5,1,2,3]
```

{% endtab %}
{% tab title='LC_61.py' %}

```py
def rotateRight(self, head: ListNode, k: int) -> ListNode:
  if not head:
    return None
  old_last = head
  length = 1
  while old_last.next:
    old_last = old_last.next
    length += 1
  k = k % length
  old_last.next = head
  new_last = head
  for _ in range(length - k - 1):
    new_last = new_last.next
  answer = new_last.next
  new_last.next = None
  return answer
```

{% endtab %}
{% endtabs %}

* [Level 2 : Design Linked List](https://leetcode.com/problems/design-linked-list)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/linkedlist/LC_707.md/)

{% tabs %}
{% tab title='LC_707.md' %}

> Question

* Implement the MyLinkedList class:
* MyLinkedList() Initializes the MyLinkedList object.
* int get(int index) Get the value of the indexth node in the linked list. If the index is invalid, return -1.
* void addAtHead(int val) Add a node of value val before the first element of the linked list
  * After the insertion, new node will be the first node of the linked list.
* void addAtTail(int val) Append a node of value val as the last element of the linked list.
* void addAtIndex(int index, int val) Add a node of value val before the indexth node in the linked list
  * If index equals length of linked list, node will be appended to end of linked list
  * If index is greater than the length, the node will not be inserted.
* void deleteAtIndex(int index) Delete the indexth node in the linked list, if the index is valid.

```txt
Input:
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]

Output:
[null, null, null, null, 2, null, 3]
```

{% endtab %}
{% tab title='LC_707.py' %}

```py
class ListNode:
  def __init__(self, val):
    self.val = val
    self.next = None


class MyLinkedList(object):
  def __init__(self):
    self.head, self.size = None, 0

  def get(self, index: int) -> int:
    if index < 0 or index >= self.size:
      return -1

    current = self.head

    for _ in range( index):
      current = current.next

    return current.val

  def addAtHead(self, val: int) -> None:
    self.addAtIndex(0, val)

  def addAtTail(self, val: int) -> None:
    self.addAtIndex(self.size, val)

  def addAtIndex(self, index: int, val: int) -> None:
    if index > self.size:
      return

    current = self.head
    new_node = ListNode(val)

    if index <= 0:
      new_node.next = current
      self.head = new_node
    else:
      for _ in range(index - 1):
        current = current.next
      new_node.next = current.next
      current.next = new_node

    self.size += 1

  def deleteAtIndex(self, index: int) -> None:
    if index < 0 or index >= self.size:
      return

    current = self.head

    if index == 0:
      self.head = self.head.next
    else:
      for _ in range(index - 1):
        current = current.next
      current.next = current.next.next

    self.size -= 1
```

{% endtab %}
{% endtabs %}

* [Level 3 : Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/list/linkedlist/LC_23.md/)

{% tabs %}
{% tab title='LC_23.md' %}

> Question

* You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
* Merge all the linked-lists into one sorted linked-list and return it.

```txt
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
```

{% endtab %}
{% tab title='LC_23.py' %}

```py
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
def mergeKLists(self, lists):
  def vals(node):
    while node:
      yield node.val
      node = node.next
  dummy = last = ListNode(None)
  for val in heapq.merge(*map(vals, lists)):
    last.next = last = ListNode(val)
  return dummy.next
```

{% endtab %}
{% endtabs %}
