> baekjoon

* [Level 12 : ì´ì§„ íŠ¸ë¦¬](https://www.acmicpc.net/problem/13325)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/binary-tree/BJ_13325.md/)

{% tabs %}
{% tab title='BJ_13325.md' %}

> Question

* Given binary tree, you want to make the sum path to root the same
* Print the sum of all nodes in result tree

```txt
Input:
2
2 2 2 1 1 3

Output: 15  # 3 2 2 2 3 3
```

{% endtab %}
{% tab title='BJ_13325.py' %}

```cpp
#include<bits/stdc++.h>
using namespace std;
int k, a[1 << 21], r, i, t;
int main() {
  cin >> k;
  for (i = 2; i < 1 << k + 1; i++) scanf("%d", a + i);
  while (i -= 2) {
    r += t = max(a[i], a[i + 1]);
    a[i / 2] += t;
  }
  cout << r + t;
  return 0;
}
```

{% endtab %}
{% endtabs %}

> codeforces

* [Level 1800 : Playoff Tournament](https://codeforces.com/contest/1535/problem/D)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/binary-tree/CF_1535D.md/)

{% tabs %}
{% tab title='CF_1535.md' %}

> Question

* let ğ‘“(ğ‘ ) be the number of possible winners of the tournament described by the string  ğ‘ 
* Given one integer ğ‘˜ (1â‰¤ğ‘˜â‰¤18), string with len 2ğ‘˜âˆ’1 initial state of string ğ‘  (?, 0, 1)
* For each query ğ‘ (1â‰¤ğ‘â‰¤2â‹…10^5)
  * for ğ‘ and a character ğ‘ (ğ‘ â‰¤ 2ğ‘˜âˆ’1; ğ‘ = ?, 0, or 1), describing ğ‘–-th query

```txt
Input:
3
0110?11
6
5 1
6 ?
7 ?
1 ?
5 ?
1 1

Output:
1
2
3
3
5
4
```

{% endtab %}
{% tab title='CF_1535.py' %}

```py
import sys
input = lambda : sys.stdin.readline().strip()
input()
S = list(input())
N = len(S)
dp = [0] * N

for i, s in enumerate(S):
  if i <= N // 2:
    dp[i] += 2 if s == '?' else 1
  else:
    d = N - i
    l, r = N - d * 2 - 1, N - d * 2
    dp[i] = dp[l] + dp[r] if S[i] == '?' else dp[r] if S[i] == '1' else dp[l]
for _ in range(int(input())):
  i, to = input().split()
  i = int(i) - 1
  S[i] = to
  while i < N:
    d = N - i
    l, r = N - d * 2 - 1, N - d * 2
    if i <= N // 2:
      dp[i] = 2 if S[i] == '?' else 1
    else:
      dp[i] = dp[l] + dp[r] if S[i] == '?' else dp[r] if S[i] == '1' else dp[l]
    d = (N - i) // 2
    i = N - d
  print(dp[-1])
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 1 : Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/binary-tree/LC_543.md/)

{% tabs %}
{% tab title='LC_543.md' %}

> Question

* Find diameter of binary tree

```txt
Input: root = [1,2,3,4,5]
Output: 3
```

{% endtab %}
{% tab title='LC_543.py' %}

```py
def diameterOfBinaryTree(self, root):
  self.ans = 0

  def depth(p):
    if not p: return 0
    left, right = depth(p.left), depth(p.right)
    self.ans = max(self.ans, left+right)
    return 1 + max(left, right)

  depth(root)
  return self.ans
```

{% endtab %}
{% endtabs %}

* [Level 2 : Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/binary-tree/LC_1448.md/)

{% tabs %}
{% tab title='LC_1448.md' %}

> Question

* Count number of good nodes in a binary tree

```txt
Input: root = [3,1,4,3,null,1,5]
Output: 4
```

{% endtab %}
{% tab title='LC_1448.cpp' %}

```cpp
int goodNodes(TreeNode* r, int ma = -10000) {
  return r ? goodNodes(r->left, max(ma, r->val)) + goodNodes(r->right, max(ma, r->val)) + (r->val >= ma) : 0;
}
```

{% endtab %}
{% tab title='LC_1448.py' %}

```py
def goodNodes(self, r, ma=-10000):
  return self.goodNodes(r.left, max(ma, r.val)) + self.goodNodes(r.right, max(ma, r.val)) + (r.val >= ma) if r else 0
```

{% endtab %}
{% endtabs %}

* [Level 2 : Count Complete Tree Nodes](https://leetcode.com/problems/count-complete-tree-nodes)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/binary-tree/LC_222.md/)

{% tabs %}
{% tab title='LC_222.md' %}

> Question

* Given the root of a complete binary tree, return the number of the nodes in the tree.
* Every level, except last, is completely filled in a complete binary tree, and all nodes in last level are as far left
* It can have between 1 and 2h nodes inclusive at the last level h.
* Design an algorithm that runs in less than O(n) time complexity.

```txt
Input: root = [1,2,3,4,5,6]
Output: 6

Input: root = [1]
Output: 1
```

{% endtab %}
{% tab title='LC_222.py' %}

```py
def countNodes(self, root):
  # Time: O(log^2 N): Master Theorem
  # Space: O(log(n))
  def getDepth(root):
    if not root:
      return 0
    return 1 + getDepth(root.left)
  if not root:
    return 0
  l_depth = getDepth(root.left)
  r_depth = getDepth(root.right)
  if l_depth == r_depth:
    return pow(2, l_depth) + self.countNodes(root.right)
  else:
    return pow(2, r_depth) + self.countNodes(root.left)

```

{% endtab %}
{% endtabs %}

* [Level 2 : House Robber III](https://leetcode.com/problems/house-robber-iii)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/binary-tree/LC_337.md/)

{% tabs %}
{% tab title='LC_337.md' %}

> Question

* automatically contact the police if two directly-linked houses were broken into on the same night
* Determine the maximum amount of money the thief can rob tonight without alerting the police

```txt
Input: root = [3,2,3,null,3,null,1]
Output: 7
```

{% endtab %}
{% tab title='LC_337.py' %}

```py
def rob(self, root: TreeNode):
  def with_without_rob(root):
    if root :
      wi_l, wo_l = with_without_rob(root.left)
      wi_r, wo_r = with_without_rob(root.right)
      return (root.val + wo_l + wo_r, max(wi_l, wo_l) + max(wi_r, wo_r))
    return (0, 0)

  return max(with_without_rob(root))
```

{% endtab %}
{% endtabs %}

* [Level 2 : Distribute Coins in Binary Tree](https://leetcode.com/problems/distribute-coins-in-binary-tree)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/binary-tree/LC_979.md/)

{% tabs %}
{% tab title='LC_979.md' %}

> Question

* Given root of a binary tree with n nodes where each node in tree has node.val coins
* There are n coins in total throughout the whole tree.
* In one move, choose two adjacent nodes and move one coin from one node to another
* A move may be from parent to child, or from child to parent.
* Return minimum number of moves required to make every node have exactly one coin

```txt
Input: root = [3,0,0]
Output: 2

Input: root = [1,0,0,null,3]
Output: 4
```

{% endtab %}
{% tab title='LC_979.py' %}

```py
res = 0
def distributeCoins(self, root):
  def dfs(root):
    if not root: return 0
    left = dfs(root.left)
    right = dfs(root.right)
    self.res += abs(left) + abs(right)
    return root.val + left + right - 1
  dfs(root)
  return self.res
```

{% endtab %}
{% endtabs %}
