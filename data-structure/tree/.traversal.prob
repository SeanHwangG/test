> baekjoon

* [Level 10 : 트리 순회](https://www.acmicpc.net/problem/1991)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/traversal/BJ_1991.md/)

{% tabs %}
{% tab title='BJ_1991.md' %}

> Question

* traversal
* inorder (left, root, right)
* preorder (root, left, right)
* postorder (left, right, root)

```txt
Input:
7
A B C
B D .
C E F
E . .
F . G
D . .
G . .

Output:
ABDCEFG
DBAECFG
DBEGFCA
```

{% endtab %}
{% tab title='BJ_1991.py' %}

```py
import sys
sys.setrecursionlimit(1000000)

n = int(input())
data2node = dict()

class Node:
  def __init__(self, data, left = None, right = None):
    self.data = data
    self.left = left
    self.right = right
def dfs(node, debug):
  if not node:
    return
  if debug == "pre":
    print(node.data, end='')
  if node.left:
    dfs(data2node[node.left.data], debug)
  if debug == "in":
    print(node.data, end='')
  if node.right:
    dfs(data2node[node.right.data], debug)
  if debug == "post":
    print(node.data, end='')

for i in range(n):
  a, b, c = input().split()
  if b != '.':
    data2node[b] = Node(b)
  if c!= '.':
    data2node[c] = Node(c)
  data2node[a] = Node(a, data2node.get(b), data2node.get(c))

for order in ["pre", "in", "post"]:
  dfs(data2node['A'], order)
  print()
```

{% endtab %}
{% endtabs %}

* [Level 10 : 이진 검색 트리](https://www.acmicpc.net/problem/5639)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/traversal/BJ_5639.md/)

{% tabs %}
{% tab title='BJ_5639.md' %}

> Question

* The result of the in-order-traverse of the binary search tree is given
* Find the results of a post-traverse of this tree

```txt
Input:
50
30
24
5
28
45
98
52
60

Output:
5
28
24
45
30
60
52
98
50
```

{% endtab %}
{% tab title='BJ_5639.py' %}

```py
import sys
sys.setrecursionlimit(10**9)
def postorder(lo, hi):
  if lo> hi:
    return
  mi= hi + 1
  for i in range(lo+1, hi+1):
    if post[lo] < post[i]:
      mi = i
      break
  postorder(lo+1,mi-1)
  postorder(mi, hi)
  print(post[lo])

post=[]
while True:
  try:
    post.append(int(input()))
  except:
    break
postorder(0,len(post)-1)
```

{% endtab %}
{% endtabs %}

* [Level 13 : 트리의 순회](https://www.acmicpc.net/problem/2263)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/traversal/BJ_2263.md/)

{% tabs %}
{% tab title='BJ_2263.md' %}

> Question

* Given inorder and postorder pring preorder traversal

```txt
Input:
3
1 2 3
1 3 2

Output: 2 1 3
```

> Solution

![BJ_2263](traversal/images/20210718_174312.png)

{% endtab %}
{% tab title='BJ_2263.py' %}

```py
import sys

sys.setrecursionlimit(10000000)

def f(i, l, r):
  if l >= r: return
  idx = pos[A[i]]
  print(A[i], end=' ')
  f(i - (r - idx), l, idx)
  f(i - 1, idx + 1, r)

n = int(input())
B, A = [*map(int, input().split())], [*map(int, input().split())]
pos = [0] * (n + 1)
for i, b in enumerate(B):
  pos[b] = i
f(n - 1, 0, n)
```

{% endtab %}
{% endtabs %}

> leetcode

* [Level 1 : Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/traversal/LC_144.md/)

{% tabs %}
{% tab title='LC_144.md' %}

> Question

* Given the root of a binary tree, return the preorder traversal of its nodes' values

```txt
Input: root = [1,null,2,3]
Output: [1,2,3]
```

{% endtab %}
{% tab title='LC_144.py' %}

```py
def preorderTraversal(self, root):
  ret, stack = [], [root]
  while stack:
    node = stack.pop()
    if node:
      ret.append(node.val)
      stack.extend([node.right, node.left])
  return ret
```

{% endtab %}
{% endtabs %}

* [Level 1 : Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/traversal/LC_145.md/)

{% tabs %}
{% tab title='LC_145.md' %}

> Question

* Given the root of a binary tree, return the postorder traversal of its nodes' values

```txt
Input: root = [1,null,2,3]
Output: [3,2,1]
```

{% endtab %}
{% tab title='LC_145.py' %}

```py
def postorderTraversal(self, root):
  traversal, stack = [], [root]
  while stack:
    node = stack.pop()
    if node:
      traversal.append(node.val)
      stack.extend([node.left, node.right])
  return traversal[::-1]
```

{% endtab %}
{% endtabs %}

* [Level 1 : Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/traversal/LC_94.md/)

{% tabs %}
{% tab title='LC_94.md' %}

> Question

* Given the root of a binary tree, return the inorder traversal of its nodes' values

```txt
Input: root = [1,null,2,3]
Output: [1,3,2]
```

{% endtab %}
{% tab title='LC_94.py' %}

```py
# Time : O(n), Space : O(n)
def inorderTraversal(self, root):
  return self.inorderTraversal(root.left)+[root.val]+self.inorderTraversal(root.right) if root else []
```

{% endtab %}
{% endtabs %}

* [Level 2 : Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/traversal/LC_230.md/)

{% tabs %}
{% tab title='LC_230.md' %}

> Question

* Given the root of a binary search tree, and an integer k, return the kth (1-indexed) smallest element in the tree

```txt
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3
```

{% endtab %}
{% tab title='LC_230.py' %}

```py
class Solution(object):
  def kthSmallest(self, root: TreeNode, k: int):
    count = []
    self.helper(root, count)
    return count[k-1]

  def helper(self, node, count):
    if not node: return
    self.helper(node.left, count)
    count.append(node.val)
    self.helper(node.right, count)
```

{% endtab %}
{% endtabs %}

* [Level 2 : N-ary Tree Level Order Traversal](https://leetcode.com/problems/n-ary-tree-level-order-traversal)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/traversal/LC_429.md/)

{% tabs %}
{% tab title='LC_429.md' %}

> Question

* Given an n-ary tree, return the level order traversal of its nodes' values

```txt
Input: root = [1,null,3,2,4,null,5,6]
Output: [[1],[3,2,4],[5,6]]
```

{% endtab %}
{% tab title='LC_429.py' %}

```py
def levelOrder(self, root):
  q, ret = [root], []
  while any(q):
    ret.append([node.val for node in q])
    q = [child for node in q for child in node.children if child]
  return ret
```

{% endtab %}
{% endtabs %}

* [Level 3 : Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/traversal/LC_987.md/)

{% tabs %}
{% tab title='LC_987.md' %}

> Question

* Given the root of a binary tree, calculate the vertical order traversal of the binary tree

![LC_987.md](traversal/images/20210509_013616.png)

```txt
Input: root = [1,2,3,4,5,6,7]
Output: [[4],[2],[1,5,6],[3],[7]]
Explanation:
Column -2: Only node 4 is in this column.
Column -1: Only node 2 is in this column.
Column 0: Nodes 1, 5, and 6 are in this column.
          1 is at the top, so it comes first.
          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.
Column 1: Only node 3 is in this column.
Column 2: Only node 7 is in this column.
```

{% endtab %}
{% tab title='LC_987.py' %}

```py
def verticalTraversal(self, root):
  g = collections.defaultdict(list)
  queue = [(root,0)]
  while queue:
    new = []
    d = collections.defaultdict(list)
    for node, s in queue:
      d[s].append(node.val)
      if node.left:  new += (node.left, s-1),
      if node.right: new += (node.right,s+1),
    for i in d: g[i].extend(sorted(d[i]))
    queue = new
  return [g[i] for i in sorted(g)]
```

{% endtab %}
{% endtabs %}
