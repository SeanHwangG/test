> leetcode

* [Level 2 : Balance a Binary Search Tree](https://leetcode.com/problems/balance-a-binary-search-tree)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/bst/LC_1382.md/)

{% tabs %}
{% tab title='LC_1382.md' %}

> Question

* Given a binary search tree, return a balanced binary search tree with the same node values
* A binary search tree is balanced if and only if the depth of the two subtrees of every node never differ by more than 1

```txt
Input: root = [1,null,2,null,3,null,4,null,null]
Output: [2,1,3,null,null,null,4]
```

{% endtab %}
{% tab title='LC_1382.py' %}

```py
class Solution:
  def balanceBST(self, root: TreeNode) -> TreeNode:

    def dfs(node):
      if not node: return []
      return dfs(node.left) + [node.val] + dfs(node.right)
    ns = dfs(root)

    def build(l, r):
      if l > r: return None
      m = (l + r) // 2
      root = TreeNode(ns[m])
      root.left, root.right = build(l, m-1), build(m + 1, r)
      return root

    return build(0, len(ns) - 1)
```

{% endtab %}
{% endtabs %}

* [Level 2 : Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/bst/LC_173.md/)

{% tabs %}
{% tab title='LC_173.md' %}

> Question

* Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):
  * BSTIterator(TreeNode root) Initializes an object of the BSTIterator class
    * The pointer should be initialized to a non-existent number smaller than any element in the BST
  * boolean hasNext() Returns true if there exists a number in traversal to right of pointer, otherwise returns false
  * int next() Moves the pointer to the right, then returns the number at the pointer

```txt
Input:
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]

Output: [null, 3, 7, true, 9, true, 15, true, 20, false]
```

{% endtab %}
{% tab title='LC_173.py' %}

```py
class BSTIterator(object):
  def __init__(self, root):
    self.root_node=root
    self.current_node=root
    self.stack=[]

  def hasNext(self):
    return self.current_node is not None or self.stack

  def next(self):
    while self.current_node:
      self.stack.append(self.current_node)
      self.current_node=self.current_node.left
    next=self.stack.pop()
    self.current_node=next.right
    return next.val
```

{% endtab %}
{% endtabs %}

* [Level 2 : Delete Node in a BST](https://leetcode.com/problems/delete-node-in-a-bst)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/bst/LC_450.md/)

```py
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
  def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
    if not root: # Root doesn't exist, just return it
      return root
    if root.val > key: # key is less than root value, find node in left subtree
      root.left = self.deleteNode(root.left, key)
    elif root.val < key: # key is greater than root value, find node in right subtree
      root.right= self.deleteNode(root.right, key)
    else: # Found node (root.value == key), start to delete it
      if not root.right: # if no right children, we delete node then new root would be root.left
        return root.left
      if not root.left: # if no left children, we delete node then new root would be root.right
        return root.right
      # if both children, replace with min value in right subtree then delete that min node in right subtree
      temp, mn = root.right, root.right.val
      while temp.left:
        temp = temp.left
        mn = temp.val
      root.val = mn # replace value
      root.right = self.deleteNode(root.right,root.val) # delete minimum node in right subtree
    return root
```

* [Level 2 : Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/bst/LC_538.md/)

{% tabs %}
{% tab title='LC_538.md' %}

> Question

* Given the root of a BST, convert it to a Greater Tree
* st every key of original BST is changed to original key plus sum of all keys greater than the original key in BST

```txt
Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

{% endtab %}
{% tab title='LC_538.py' %}

```py
class Solution:
  def __init__(self):
    self.total = 0

  def convertBST(self, root: TreeNode) -> TreeNode:
    if not root:
      return
    self.convertBST(root.right)
    root.val += self.total
    self.total = root.val
    self.convertBST(root.left)
    return root
```

{% endtab %}
{% endtabs %}

* [Level 2 : Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree)
  * [Update solution](https://github.com/seanhwangg/blog/tree/main/data-structure/tree/bst/LC_98.md/)

{% tabs %}
{% tab title='LC_98.md' %}

> Question

* Check if tree is valid BST

```txt
Input: root = [5,1,4,null,null,3,6]
Output: false
```

{% endtab %}
{% tab title='LC_98.cpp' %}

```cpp
class Solution {
public:
  bool isValidBST(TreeNode* root, long min = LONG_MIN, long max = LONG_MAX) {
    if (root == NULL) return true;
    if (root->val <= min || root->val >= max) return false;
    return isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, max);
  }
};
```

{% endtab %}
{% tab title='LC_98.py' %}

```py
def isValidBST(self, root: TreeNode, left = float('-inf'), right = float('inf')) -> bool:
  return not root or left < root.val < right and \
      self.isValidBST(root.left, left, root.val) and \
      self.isValidBST(root.right, root.val, right)
```

{% endtab %}
{% endtabs %}
